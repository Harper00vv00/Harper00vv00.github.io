{"meta":{"title":"Eloise Wang","subtitle":"Eloise的记事本","description":"","author":"Eloise_W","url":"https://Harper00vv00/Harper00vv00.github.io","root":"/"},"pages":[{"title":"about","date":"2022-09-04T15:13:32.000Z","updated":"2022-09-04T15:20:18.960Z","comments":true,"path":"about/index.html","permalink":"https://harper00vv00/Harper00vv00.github.io/about/index.html","excerpt":"","text":"profile: avater: #头像 career: 打工人 introduction： 一技之长，衣食无忧 my Projects: enable: false my Skills: enable: true data: cpp: background: ‘linear-gradient(to right, #9900FF 0%, #CC66FF 100%)’ percent: 80% my Gallery: #相册 enable: false"},{"title":"categories","date":"2022-09-04T15:27:32.000Z","updated":"2022-09-04T15:28:29.097Z","comments":true,"path":"categories/index.html","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-09-04T15:26:50.000Z","updated":"2022-09-04T15:29:12.928Z","comments":true,"path":"friends/index.html","permalink":"https://harper00vv00/Harper00vv00.github.io/friends/index.html","excerpt":"","text":""},{"title":"contact","date":"2022-09-04T15:26:34.000Z","updated":"2022-09-04T15:28:51.838Z","comments":true,"path":"contact/index.html","permalink":"https://harper00vv00/Harper00vv00.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-09-04T15:20:33.000Z","updated":"2022-09-04T15:21:33.872Z","comments":true,"path":"tags/index.html","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"栈与队列","slug":"栈与队列","date":"2022-09-21T13:36:59.000Z","updated":"2022-09-21T13:39:20.077Z","comments":true,"path":"2022/09/21/栈与队列/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/21/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","excerpt":"LeetCode算法数据结构Day1","text":"栈的基本操作 //1 标准库与定义 #include&lt;stack> stack&lt;int> s; //2 基础操作 s.empty(); //如果栈为空则返回true, 否则返回false; s.size(); //返回栈中元素的个数 s.top(); //返回栈顶元素, 但不删除该元素 s.pop(); //弹出栈顶元素, 但不返回其值 s.push(); //将元素压入栈顶 栈练习题1剑指 Offer 09. 用两个栈实现队列用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead&nbsp;操作返回 -1 )解题思路 自己写的代码以及遇到的问题 class CQueue { private: stack&lt;int> A;//入栈 stack&lt;int> B;//出栈 public: CQueue() { //默认构造函数 } void appendTail(int value) { A.push(value); } int deleteHead() { if(!B.empty())//B非空 { int res=B.top(); B.pop(); return res; } if(A.empty()) { return -1; } while(!A.empty()) { int val=A.top(); A.pop(); B.push(val); continue; } int result=B.top(); B.pop(); return result; } }; /** * Your CQueue object will be instantiated and called as such: * CQueue* obj = new CQueue(); * obj->appendTail(value); * int param_2 = obj->deleteHead(); 解题过程中遇到的问题： 1. 编译错误：non-void function does not return a value in all control paths [-Werror,-Wreturn-type] 修改：如果B非空为第一种可能性，那么第二种可能性就是default，不用写if(B空) */ 栈练习题2剑指 Offer 30. 包含 min 函数的栈定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。解题思路自己写的代码以及遇到的问题 class MinStack { public: stack&lt;int> s,minstack; public: /** initialize your data structure here. */ MinStack() { } void push(int x) { s.push(x); if(minstack.empty()||x&lt;=minstack.top()) minstack.push(x); } void pop() { int top_s,top_minstack; top_s=s.top(); top_minstack=minstack.top(); if(top_s==top_minstack) minstack.pop(); s.pop(); } int top() { return s.top(); } int min() { return minstack.top(); } }; /** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj->push(x); * obj->pop(); * int param_3 = obj->top(); * int param_4 = obj->min(); 1 执行错误：Line 175: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0ba for type 'int', which requires 4 byte alignment (stl_deque.h) 0xbebebebebebec0ba: note: pointer points here &lt;memory cannot be printed> SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_deque.h:180:16 修改：push函数 if(x&lt;minstack.top())改成if(x&lt;=minstack.top()) 原因：有可能最后两个push的数都是最小值，然而pop函数将最小值pop掉只留次小 2 执行结果（答案）错误 修改：push函数 两行if改成if(minstack.empty()||x&lt;=minstack.top()) 或者 if。。else if。。 原因：如果不使用“或”，而拆分成两行if，当minstack为空，会push两次 */ 小结1 解题时先分析不同方法的时间复杂度2 解题时一定要注意边界条件是“&gt;”还是“&gt;=” 其他栈的拓展阅读","categories":[{"name":"C++基础","slug":"C-基础","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/LeetCode/"},{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/C/"},{"name":"栈","slug":"栈","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E9%98%9F%E5%88%97/"}]},{"title":"常用电子元器件","slug":"常用电子元器件","date":"2022-09-21T13:00:37.000Z","updated":"2022-09-21T13:26:09.429Z","comments":true,"path":"2022/09/21/常用电子元器件/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/21/%E5%B8%B8%E7%94%A8%E7%94%B5%E5%AD%90%E5%85%83%E5%99%A8%E4%BB%B6/","excerpt":"一些很常用的电子元器件在电路中的作用","text":"电容 降压工作原理：利用电容在一定的交流信号频率下产生的容抗来限制最大工作电流。容抗：Xc=1/(2πfC)❓为什么不用电阻降压：因为电阻消耗有功功率，存在发热问题；而电容消耗无功功率几乎不消耗能源，还不发热 例如在50Hz的工频条件下，一个1uF的电容所产生的容抗约为3180欧姆。当220V的交流电压加在电容器的两端，则流过电容的最大电流约为70mA。虽然流过电容的电流有70mA，但在电容器上并不产生功耗，因为如果电容是一个理想电容，则流过电容的电流为虚部电流，它所作的功为无功功率。根据这个特点，我们如果在一个1uF的电容器上再串联一个阻性元件，则阻性元件两端所得到的电压和它所产生的功耗完全取决于这个阻性元件的特性。 容性无功功率在电网中被当作无功电源，感性无功功率在电网中被当作无功负载 应用：将交流市电转换为低压直流的常规方法是采用变压器降压后再整流滤波，当受体积和成本等因素的限制时，最简单实用的方法就是采用电容降压式电源 注意事项 滤波隔直通交：直流电频率f=0Hz；容抗随着频率的增加而减小 电容阻抗-频率曲线理解blog 高通滤波器：并非把低频信号完全滤除，只是低频信号的幅度削减更大，高频信号幅度削减更小 选滤波电容的原则：选阻抗最低的电容 延时给电容充电时，电容的充电曲线并非一条直线，因此可以用作延时电路下图是常用RC延时电路以及上电后的波形充电时间的公式：充电时间 T = - ln ( ( VCC - Vout ) / VCC ) * R * C 从0.1Vout充电到0.9Vout需要时间2.2RC 单片机波形，若想要给高电平信号一个延时，可以使用RC延时电路 耦合电容隔直通交，可以将我们需要的交流信号从前级电路近似无衰减地耦合到后级电路，将我们不需要的直流信号进行去耦（隔断） 旁路滤除高频交流信号常见模型：给单片机供电时，习惯性地在电源与地中间加一个0.1uf的小电容，这样，高频干扰信号会通过小电容流向地，使芯片免受高频信号的干扰且旁路电容一般都紧靠芯片（物理紧靠），如果电容距离芯片太原，效果将大打折扣（导线受噪声、电磁干扰影响产生高频信号） 很多数据手册上，旁路电容通常是2个电容并联工作，且小电容更紧靠芯片，这是因为容值小的电容，有最高的谐振频率，能滤除更高频的电波 电感…Waiting 三极管…Waiting 。。。…Waiting 采用【电容降压】时应注意以下几点： 1. 根据负载的电流大小和交流电的工作频率选取适当的电容，而不是依据负载的电压和功率。 2. 限流电容必须采用无极性电容，绝对不能采用电解电容。而且电容的耐压须在400V以上。最理想的电容为铁壳油浸电容。 3. 电容降压不能用于大功率负载，因为不安全。 4. 电容降压不适合动态负载。 5. 同样，电容降压不适合容性和感性负载。 6. 当需要直流工作时，尽量采用半波整流。不建议采用桥式整流， 因为全波整流产生浮置的地，并在零线和火线之间产生高压，造成人体触电伤害。而且要满足恒定负载的条件。","categories":[{"name":"-电子电路","slug":"电子电路","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/"}],"tags":[{"name":"-电路","slug":"电路","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E7%94%B5%E8%B7%AF/"}]},{"title":"try_catch","slug":"try-catch","date":"2022-09-21T12:50:25.000Z","updated":"2022-09-21T12:55:21.318Z","comments":true,"path":"2022/09/21/try-catch/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/21/try-catch/","excerpt":"上课没学但很重要的try。。catch语法理解","text":"基本语法 throw 表达式; try { 语句组 } catch(异常类型) { 异常处理代码 } ... catch(异常类型) { 异常处理代码 } catch 可以有多个，但至少要有一个。 不妨把 try 和其后{}中的内容称作“try块”，把 catch 和其后{}中的内容称作“catch块”。 try…catch 语句的执行过程是： 执行 try 块中的语句，如果执行的过程中没有异常拋出，那么执行完后就执行最后一个 catch 块后面的语句，所有 catch 块中的语句都不会被执行； 如果 try 块执行的过程中拋出了异常，那么拋出异常后立即跳转到第一个“异常类型”和拋出的异常类型匹配的 catch 块中执行（称作异常被该 catch 块“捕获”），执行完后再跳转到最后一个 catch 块后面继续执行。 示例 #include &lt;iostream> using namespace std; int main() { double m ,n; cin >> m >> n; try { cout &lt;&lt; \"before dividing.\" &lt;&lt; endl; if( n == 0) throw -1; //抛出int类型异常 else cout &lt;&lt; m / n &lt;&lt; endl; cout &lt;&lt; \"after dividing.\" &lt;&lt; endl; } catch(double d) { cout &lt;&lt; \"catch(double) \" &lt;&lt; d &lt;&lt; endl; } catch(int e) { cout &lt;&lt; \"catch(int) \" &lt;&lt; e &lt;&lt; endl; } cout &lt;&lt; \"finished\" &lt;&lt; endl; return 0; } 程序的运行结果如下：9 6↙before dividing.1.5after dividing.finished 说明当 n 不为 0 时，try 块中不会拋出异常。因此程序在 try 块正常执行完后，越过所有的 catch 块继续执行，catch 块一个也不会执行。 程序的运行结果也可能如下：9 0↙before dividing.catch(int) -1finished 当 n 为 0 时，try 块中会拋出一个整型异常。拋出异常后，try 块立即停止执行。该整型异常会被类型匹配的第一个 catch 块捕获，即进入catch(int e)块执行，该 catch 块执行完毕后，程序继续往后执行，直到正常结束。 能够捕获任何异常的 catch 语句catch(...) {异常处理代码} 抛出“类”的异常 #include &lt;iostream> #include &lt;string> using namespace std; class CException { public: string msg; CException(string s) : msg(s) {} }; double Devide(double x, double y) { if (y == 0) throw CException(\"devided by zero\"); cout &lt;&lt; \"in Devide\" &lt;&lt; endl; return x / y; } int CountTax(int salary) { try { if (salary &lt; 0) throw - 1; cout &lt;&lt; \"counting tax\" &lt;&lt; endl; } catch (int) { cout &lt;&lt; \"salary &lt; 0\" &lt;&lt; endl; } cout &lt;&lt; \"tax counted\" &lt;&lt; endl; return salary * 0.15; } int main() { double f = 1.2; try { CountTax(-1); f = Devide(3, 0); cout &lt;&lt; \"end of try block\" &lt;&lt; endl; } catch (CException e) { cout &lt;&lt; e.msg &lt;&lt; endl; } cout &lt;&lt; \"f = \" &lt;&lt; f &lt;&lt; endl; cout &lt;&lt; \"finished\" &lt;&lt; endl; return 0; } 程序的输出结果如下：salary &lt; 0tax counteddevided by zerof=1.2finished 拋出的异常是派生类的对象，而 catch 块的异常类型是基类，那么这两者也能够匹配，因为派生类对象也是基类对象。 C++标准异常类C++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的。bad_typeid、bad_cast、bad_alloc、ios_base::failure、out_of_range 都是 exception 类的派生类。C++ 程序在碰到某些异常时，即使程序中没有写 throw 语句，也会自动拋出上述异常类的对象。这些异常类还都有名为 what 的成员函数，返回字符串形式的异常描述信息。使用这些异常类需要包含头文件stdexcept 以下是自己写程序时经常遇到的错误1.bad_alloc在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常。程序示例如下： #include &lt;iostream> #include &lt;stdexcept> using namespace std; int main() { try { char * p = new char[0x7fffffff]; //无法分配这么多空间，会抛出异常 } catch (bad_alloc &amp; e) { cerr &lt;&lt; e.what() &lt;&lt; endl; } return 0; } 程序的输出结果如下：bad allocationios_base::failure 在默认状态下，输入输出流对象不会拋出此异常。如果用流对象的 exceptions 成员函数设置了一些标志位，则在出现打开文件出错、读到输入流的文件尾等情况时会拋出此异常。此处不再赘述。 2.out_of_range用 vector 或 string 的 at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常。例如： #include &lt;iostream> #include &lt;stdexcept> #include &lt;vector> #include &lt;string> using namespace std; int main() { vector&lt;int> v(10); try { v.at(100) = 100; //拋出 out_of_range 异常 } catch (out_of_range &amp; e) { cerr &lt;&lt; e.what() &lt;&lt; endl; } string s = \"hello\"; try { char c = s.at(100); //拋出 out_of_range 异常 } catch (out_of_range &amp; e) { cerr &lt;&lt; e.what() &lt;&lt; endl; } return 0; } 程序的输出结果如下：invalid vector subscriptinvalid string position 如果将v.at(100)换成v[100]，将s.at(100)换成s[100]，程序就不会引发异常（但可能导致程序崩溃）。 因为 at 成员函数会检测下标越界并拋出异常，而 operator[] 则不会。 operator [] 相比 at 的好处就是不用判断下标是否越界，因此**执行速度更快。**","categories":[{"name":"C++项目","slug":"C-项目","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/C-%E9%A1%B9%E7%9B%AE/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/C/"},{"name":"debug","slug":"debug","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/debug/"}]},{"title":"DP-Day5","slug":"DP-Day5","date":"2022-09-21T12:13:29.000Z","updated":"2022-09-21T12:58:41.860Z","comments":true,"path":"2022/09/21/DP-Day5/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/21/DP-Day5/","excerpt":"出界的路径数","text":"第一题给你一个大小为 m x n 的网格和一个球。球的起始坐标为 [startRow, startColumn] 。你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你最多可以移动 maxMove 次球。给你五个整数 m、n、maxMove、startRow 以及 startColumn ，找出并返回可以将球移出边界的路径数量。因为答案可能非常大，返回对 10^9 + 7 取余 后的结果。原题链接 自己的思路 原作者解析1、能否使用动态规划求解？2、两种「动态规划」求解方法 ☝根据经验猜一个「状态定义」，然后根据「状态定义」去推导一个「状态转移方程」。（经验解法） ✌先写一个「记忆化搜索」解法，再将「记忆化搜索」改写成「动态规划」。（技巧解法） **技巧解法** 「技巧解法」是将「记忆化搜索」翻译成「动态规划」 1、得出「记忆化搜索」的DFS函数 1⃣函数的参数和返回值 2⃣函数中会变化的参数 **重点放在 DFS 函数签名中的「可变参数」与「返回值」** 以本题为例：DFS函数： int dfs(int m, int n, int x, int y, int k) {} 可变变量：(x,y) 代表当前所在的位置，k 代表最多的移动次数返回值：代表路径数量。 设计数组存储对应信息：二维数组 f[][]作为 DP 数组：第一维代表 DFS 可变参数中的 (x,y)(x,y) 所对应 indexindex。取值范围为 [0, m*n)第二维代表 DFS 可变参数中的 kk。取值范围为 [0,N]因此，状态被定义为：f[i][j] 代表从位置 i 出发，可用步数不超过 j 时的路径数量。 2、推断出状态定义后，从「最后一步」来推导出「转移方程」(x,y) 出发的路径数量 = 上方 (x-1,y) 的路径数量 + 下方 (x+1,y) 的路径数量 + 左方 (x,y-1) 的路径数量 + 右方 (x,y+1) 的路径数量即f[(x,y)][step]=f[(x−1,y)][step−1]+f[(x+1,y)][step−1]+f[(x,y−1)][step−1]+f[(x,y+1)][step−1]从转移方程中我们发现，更新 f[i][j] 依赖于 f[x][j-1]，因此我们转移过程中需要将最大移动步数（step）进行从小到大枚举。至此，已推导出「状态转移方程」 3、找到「有效值」作为初始化状态因为整个转移过程是一个累加过程，如果没有一些有效的状态（非零值）进行初始化的话，整个递推过程并没有意义。在本题中，如果已经位于矩阵边缘的时候，我们可以一步跨出矩阵，算作一条路径。同时，由于我们能够往四个方向进行移动，因此不同的边缘格子会有不同数量的路径。! 原作者的代码 class Solution { int mod = (int)1e9+7; int m, n, N; public int findPaths(int _m, int _n, int _N, int _i, int _j) { m = _m; n = _n; N = _N; // f[i][j] 代表从 idx 为 i 的位置出发，移动步数不超过 j 的路径数量 int[][] f = new int[m * n][N + 1]; // 初始化边缘格子的路径数量 for (int i = 0; i &lt; m; i++) { for (int j = 0; j &lt; n; j++) { if (i == 0) add(i, j, f); if (i == m - 1) add(i, j, f); if (j == 0) add(i, j, f); if (j == n - 1) add(i, j, f); } } // 定义可移动的四个方向 int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}}; // 从小到大枚举「可移动步数」 for (int step = 1; step &lt;= N; step++) { // 枚举所有的「位置」 for (int k = 0; k &lt; m * n; k++) { int x = parseIdx(k)[0], y = parseIdx(k)[1]; for (int[] d : dirs) { int nx = x + d[0], ny = y + d[1]; // 如果位置有「相邻格子」，则「相邻格子」参与状态转移 if (nx >= 0 &amp;&amp; nx &lt; m &amp;&amp; ny >= 0 &amp;&amp; ny &lt; n) { f[k][step] += f[getIndex(nx, ny)][step - 1]; f[k][step] %= mod; } } } } // 最终结果为从起始点触发，最大移动步数不超 N 的路径数量 return f[getIndex(_i, _j)][N]; } // 为每个「边缘」格子，添加一条路径 void add(int x, int y, int[][] f) { int idx = getIndex(x, y); for (int step = 1; step &lt;= N; step++) { f[idx][step]++; } } // 将 (x, y) 转换为 index int getIndex(int x, int y) { return x * n + y; } // 将 index 解析回 (x, y) int[] parseIdx(int idx) { return new int[]{idx / n, idx % n}; } } //作者：宫水三叶 //链接：https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/r8doce/","categories":[{"name":"C++基础","slug":"C-基础","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/LeetCode/"},{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/C/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/DFS/"}]},{"title":"无痛自律","slug":"无痛自律","date":"2022-09-21T12:02:07.000Z","updated":"2022-09-21T12:12:10.257Z","comments":true,"path":"2022/09/21/无痛自律/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/21/%E6%97%A0%E7%97%9B%E8%87%AA%E5%BE%8B/","excerpt":"心理学相关理论，如何变得自律","text":"首要原则不能勉强，否则难以坚持，并会伴随巨大的挫败感技巧普雷马克（Premack）原理： 用高频行为（喜欢的行为）作为低频行为（不喜欢的行为）的有效强化物 *举例* 把喜欢的歌曲留到运动或学习时间听 喜欢的饮料零食留到学习时候吃 喜欢的视频留到吃健康餐的时候看。。 总而言之，干不喜欢做的事情时，搭配一件喜欢的事❤ 早睡早起。。根据某一研究，人类潜意识地把中午12点作为一天的中间点因此早期人心理上觉得时间充足 专业课的学习tips 减轻心理负担坚持每天学习7小时，放弃以“达成xx目标”量化一天的成就。每天都能做到一定的学习时间，即使没有达到目标成果，也没什么心理负担 看书时听喜欢的音乐平时不要听，即使听歌时会走神，也没有关系，学习够足够的时间就行 学习时用喜欢的香水能让自己更开心除此之外，还能促进记忆————特异性编码，考试时用同样的香水，能够帮助回忆 多本书一起看，腻了换一本 小结其实看上面4点，会有无效努力的side effect，只关注时间可能是在感动自己不过既然是无痛学习，在平时积累时间，即使每天只有半小时，总比没学好☺付出过的努力过的，总会体现出来的👊最重要的是心理上的心安理得，减少内耗 自律不是终极目标，Maximum Happiness才是✌~","categories":[{"name":"生活","slug":"生活","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"豆瓣","slug":"豆瓣","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E8%B1%86%E7%93%A3/"},{"name":"心理学","slug":"心理学","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"}]},{"title":"常用md格式","slug":"常用md格式","date":"2022-09-21T11:10:17.000Z","updated":"2022-09-21T12:09:41.475Z","comments":true,"path":"2022/09/21/常用md格式/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/21/%E5%B8%B8%E7%94%A8md%E6%A0%BC%E5%BC%8F/","excerpt":"自己写hexo博客的常用格式","text":"标题 &lt;font size=6 face=”黑体”&gt;**示例&lt;font face=”微软雅黑” size=6 color=#A52A2A&gt;**示例 字体颜色 效果 名字 代码 文字 红色 #FF0000 文字 深绿 #008000 文字 深天蓝 #00BFFF 文字 金色 #FFD700 文字 橘色 #FFA500 代码：&lt;font color=#&gt; 文字背景色 颜色 名字 代码 三文鱼 #FA8072 深橙色 #FF8C00 橙子 #FFA500 黄色 #FFFF00 黄绿色 #7FFF00 青色 #00FFFF 绿松石 #40E0D0 深蓝 #00BFFF 浅粉红 #FFB6C1 沙棕 #F4A460 代码：&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=# &gt; &lt;/td&gt; 表情符号 符号 代码 符号 代码 符号 代码 ❤ :heart: 💙 :blue_heart: 💔 :broken_heart: ✨ :sparkles: 😊 :blush: ☺ :relaxed: 😇 :innocent: 😅 :sweat_smile: 😓 :sweat: 💧 :droplet: 😭 :sob: 😱 :scream: 😡 :rage: ❓ :question: ❗ :exclamation: 💦 :sweat_drops: 👍 :thumbsup: 👎 :thumbsdown\\: 👊 :punch: ✌ :v: 🙏 :pray: ➡ :arrow_right: 🚫 :no_entry_sign: 🆚 :vs: ❗ :heavy_exclamation_mark: ❌ :x: ✅ :white_check_mark: 🔗 :link: 📌 :pushpin: 💡 :bulb:","categories":[],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/markdown/"}]},{"title":"DP-Day4","slug":"DP-Day4","date":"2022-09-15T11:44:18.000Z","updated":"2022-09-21T12:57:28.310Z","comments":true,"path":"2022/09/15/DP-Day4/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/15/DP-Day4/","excerpt":"统计所有可行路径","text":"第一题给你一个互不相同的整数数组，其中&nbsp;locations[i]&nbsp;表示第&nbsp;i&nbsp;个城市的位置。同时给你&nbsp;start，finish&nbsp;和&nbsp;fuel&nbsp;分别表示出发城市、目的地城市和你初始拥有的汽油总量每一步中，如果你在城市 i&nbsp;，你可以选择任意一个城市 j&nbsp;，满足 &nbsp;j != i&nbsp;且&nbsp;0 &lt;= j &lt; locations.length&nbsp;，并移动到城市&nbsp;j&nbsp;。从城市&nbsp;i&nbsp;移动到&nbsp;j&nbsp;消耗的汽油量为&nbsp;|locations[i] - locations[j]|，|x|&nbsp;表示&nbsp;x&nbsp;的绝对值。请注意，&nbsp;fuel&nbsp;任何时刻都&nbsp;不能&nbsp;为负，且你&nbsp;可以&nbsp;经过任意城市超过一次（包括&nbsp;start&nbsp;和&nbsp;finish&nbsp;）。请你返回从&nbsp;start&nbsp;到&nbsp;finish&nbsp;所有可能路径的数目。由于答案可能很大， 请将它对&nbsp;10^9 + 7&nbsp;取余后返回。链接在这里 原思路定义变量：b、e分别表示每一次移动的起点与终点，每次移动step步 对比作者的思路路径问题-&gt;DFS-&gt;DFS问题为指数级别复杂度-&gt;记忆化搜索 实现DFS的通常步骤1、设计好递归函数的「入参」和「出参」2、设置好递归函数的出口（Base Case）3、编写「最小单元」处理逻辑其中，最重要的是要找出Base Case，也就是确定在什么情况下，算一次有效/无效本题的有效情况：当前所在位置为finish本题无效情况：1、油量消耗完，且当前位置不在finish 2、油量不为0，但无法移动到任何位置接着，添加记忆化搜索记忆化搜索就是使用变量（通常是数组）记录当前状态，也就是中间结果我们用 cache[i][fuel] 代表从位置 i 出发，当前剩余的油量为 fuel 的前提下，到达目标位置的「路径数量」。之所以能采取「缓存中间结果」这样的做法，是因为「在 i 和 fuel 确定的情况下，其到达目的地的路径数量是唯一确定的」。与自己的思路区别：作者的中间状态（最小单元）有2个变量：fuel和起点，也就是自己定义的step和b比自己定义的中间状态少了一个变量自己定义的三维数组存储的是是否存在路径*而作者定义的二维数组存储了成立的路径数量我想作者如此定义中间状态的原因主要参考了本题的有效情况（到达finish）和所需output所以以后定义中间状态变量时遇到维度过多的情况，可以考虑使用“数量”代替“存在”，利用变量的取值减少一个维度* DFS（深度优先搜索）的框架 function dfs(当前状态){ if(当前状态 == 目的状态){ ··· } for(···寻找新状态){ if(状态合法){ vis[访问该点]； dfs(新状态); ?是否需要恢复现场-&gt;vis[恢复访问] } } if(找不到新状态){ ··· } } //CSDN博主「HeartFireY」的原创文章 //原文链接：https://blog.csdn.net/yanweiqi1754989931/article/details/109603384 //制作很精美的博文（DFS介绍） 作者宫水三叶的代码 class Solution { int mod = 1000000007; // 缓存器：用于记录「特定状态」下的结果 // cache[i][fuel] 代表从位置 i 出发，当前剩余的油量为 fuel 的前提下，到达目标位置的「路径数量」 int[][] cache; public int countRoutes(int[] ls, int start, int end, int fuel) { int n = ls.length; // 初始化缓存器 // 之所以要初始化为 -1 // 是为了区分「某个状态下路径数量为 0」和「某个状态尚未没计算过」两种情况 cache = new int[n][fuel + 1]; for (int i = 0; i &lt; n; i++) { Arrays.fill(cache[i], -1); } return dfs(ls, start, end, fuel); } /** * 计算「路径数量」 * @param ls 入参 locations * @param u 当前所在位置（ls 的下标） * @param end 目标哦位置（ls 的下标） * @param fuel 剩余油量 * @return 在位置 u 出发，油量为 fuel 的前提下，到达 end 的「路径数量」 */ int dfs(int[] ls, int u, int end, int fuel) { // 如果缓存器中已经有答案，直接返回————记忆化搜索 if (cache[u][fuel] != -1) { return cache[u][fuel]; } int n = ls.length; // base case 1：如果油量为 0，且不在目标位置 // 将结果 0 写入缓存器并返回 if (fuel == 0 &amp;&amp; u != end) { cache[u][fuel] = 0; return 0; } // base case 2：油量不为 0，且无法到达任何位置 // 将结果 0 写入缓存器并返回 boolean hasNext = false; for (int i = 0; i &lt; n; i++) { if (i != u) { int need = Math.abs(ls[u] - ls[i]); if (fuel >= need) { hasNext = true; break; } } } if (fuel != 0 &amp;&amp; !hasNext) { cache[u][fuel] = u == end ? 1 : 0; return cache[u][fuel]; } // 计算油量为 fuel，从位置 u 到 end 的路径数量 // 由于每个点都可以经过多次，如果 u = end，那么本身就算一条路径 int sum = u == end ? 1 : 0; for (int i = 0; i &lt; n; i++) { if (i != u) { int need = Math.abs(ls[i] - ls[u]); if (fuel >= need) { sum += dfs(ls, i, end, fuel - need); sum %= mod; } } } cache[u][fuel] = sum; return sum; } } 简化Base Case简化Base Case就是要深入挖掘有/无效情况原先定义的无效情况：下一步（是一步）无法达到finish其实，如果当前位置经计算无法达到finish，那么任移动几步都无法达到finish代码变化： // 如果一步到达不了，说明从位置 u 不能到达 end 位置 // 将结果 0 写入缓存器并返回 int need = Math.abs(ls[u] - ls[end]); if (need > fuel) { cache[u][fuel] = 0; return 0; } //上述代码将替换原先两个Base Case 进阶:动态规划求解❓如何将本题使用动态规划的方式求解？任何「记忆化搜索」都能改成「动态规划」。 如何直接将「记忆化搜索」改成「动态规划」。 使用这种技巧，你将不需要去猜「状态定义」和根据「状态定义」推导「状态转移方程」。 1、关注DFS函数的参数 ``` int dfs(int[] ls, int u, int end, int fuel) {} ``` 其中，ls(location)和end(finish)在DFS过程中不会改变 而u和fuel分别表示当前位置和当前油量，是可变参数 那么，定义二维数组f，分别表示两个可变参数 第一维代表当前位置，第二维代表剩余油量 数组存储DFS的返回值（路径数量） 2、翻译出「状态转移方程」第一步的“翻译”工作后，我们得到了「动态规划」的「状态定义」。所谓的「状态转移方程」其实就是指如何从一个状态转移到另外一个状态。而我们的 DFS 主逻辑就是完成这个转移的。DFS 中的主逻辑很简单：枚举所有的位置，看从当前位置 u 出发，可以到达的位置有哪些。于是我们很容易就可以得出状态转移方程：f[i][fuel]=f[i][fuel]+f[k][fuel-need]k 代表计算位置 i 油量 fuel 的状态时枚举的「下一位置」，need 代表从 i 到达 k 需要的油量。 i 和 k 并无严格的大小关系，而 fuel 和 fuel-need 具有严格的大小关系（fuel ≥ fuel−need）。因此我们需要先从小到大枚举油量这一维。 int mod = 1000000007; public int countRoutes(int[] ls, int start, int end, int fuel) { int n = ls.length; // f[i][j] 代表从位置 i 出发，当前油量为 j 时，到达目的地的路径数 int[][] f = new int[n][fuel + 1]; // 对于本身位置就在目的地的状态，路径数为 1 for (int i = 0; i &lt;= fuel; i++) f[end][i] = 1; // 从状态转移方程可以发现 f[i][fuel]=f[i][fuel]+f[k][fuel-need] // 在计算 f[i][fuel] 的时候依赖于 f[k][fuel-need] // 其中 i 和 k 并无严格的大小关系 // 而 fuel 和 fuel-need 具有严格大小关系：fuel >= fuel-need // 因此需要先从小到大枚举油量 for (int cur = 0; cur &lt;= fuel; cur++) { for (int i = 0; i &lt; n; i++) { for (int k = 0; k &lt; n; k++) { if (i != k) { int need = Math.abs(ls[i] - ls[k]); if (cur >= need) { f[i][cur] += f[k][cur-need]; f[i][cur] %= mod; } } } } } return f[start][fuel]; } } //作者：宫水三叶 //链接：https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/r8n0h2/ 总结整个过程：1、从 DFS 方法签名出发。分析哪些入参是可变的，将其作为 DP 数组的维度；将返回值作为 DP 数组的存储值。2、从 DFS 的主逻辑可以抽象中单个状态的计算方法。 其中第一点对应了「动态规划」的「状态定义」，第二点对应了「动态规划」的「状态方程转移」。 作者对这几章练习的小结两种求解「动态规划」问题的方法：1、根据经验猜一个「状态定义」，然后根据「状态定义」去推导一个「状态转移方程」。2、先写一个「记忆化搜索」解法，再将「记忆化搜索」改写成「动态规划」。 能够去猜「状态定义」或者使用「记忆化搜索」求解，都有一个大前提：问题本身具有无效性。 如果遇到一道你从来没接触过的题目时，建议先想想「记忆化搜索」该如何实现，然后反推出「动态规划」。这里说的想想「记忆化搜索」该如何实现，不需要真正动手实现一个「记忆化搜索」解法，而只需要想清楚，如果使用「记忆化搜索」的话，我的 DFS 函数参数和返回值如何设计即可。","categories":[{"name":"C++基础","slug":"C-基础","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/LeetCode/"},{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/C/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/DFS/"}]},{"title":"DP-Day3","slug":"DP-Day3","date":"2022-09-14T11:49:44.000Z","updated":"2022-09-21T12:58:30.059Z","comments":true,"path":"2022/09/14/DP-Day3/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/14/DP-Day3/","excerpt":"下降路径最小和","text":"第一题给你一个 n x n 的方形整数数组&nbsp;matrix ，请你找出并返回通过 matrix 的下降路径的最小和。下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。链接在这里！ 思路：蛮简单的感觉，用上一道题的方法，直接更改matrix，节约空间（但是直接更改原数据十分危险） class Solution { public: int minFallingPathSum(vector&lt;vector&lt;int>>&amp; matrix) { int m=matrix.size();//矩阵的行、列 for(int i=1;i&lt;m;i++) { for(int j=0;j&lt;m;j++) { int lft,mid,rht; lft=(j!=0)?matrix[i-1][j-1]+matrix[i][j]:INT_MAX; mid=matrix[i-1][j]+matrix[i][j]; rht=(j!=m-1)?matrix[i-1][j+1]+matrix[i][j]:INT_MAX; matrix[i][j]=min(lft,mid); matrix[i][j]=min(matrix[i][j],rht); } } //找到最后一行最小的路径值 int ans=INT_MAX; for(int i=0;i&lt;m;i++) { ans=min(ans,matrix[m-1][i]); } return ans; } }; 原作者宫水三叶的解析其实细看可以发现，自己的解法相当于作者动态规划（基于定义）的解法还有一个复杂度较高的解法： 基于起点解法的原理：起点任选，每一个起点都存在最小路径，那么相当于把问题拆分成两步1、找到一个起点u的最小路径——find函数2、遍历所有找到的最小路径，找出最小点——for(遍历所有u){find(u,)}整套算法时间复杂度O(n^3) 那么就从理论上学习一下自己写的代码吧！动态规划（基于定义）观察上一个解法的步骤：1、枚举起点 2、DP求最小路径和(find函数)DP的复杂程度无法优化，那么我们选择优化枚举的过程 直接从 DP 定义出发，进行转移即可。定义 f[i][j]为到达位置 (i,j) 的最小路径和。那么最终答案为所有 f[n-1][i]的最小值，i的取值范围为 [0,n)。代表最小路径的结尾可能是最后一行的任意位置。 第二题给你一个&nbsp;n x n 整数矩阵&nbsp;arr&nbsp;，请你返回 非零偏移下降路径 数字和的最小值。非零偏移下降路径 定义为：从&nbsp;arr 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。 代码最后的注释包含了本人做这题的心路历程，其实这题很简单 class Solution { public: int getId(int x,int y,int n) { return x*n+y; } int getRow(int x,int n) { return x/n;//注意整除符号不要写成转义符号！ } int getCol(int x,int n) { return x%n; } int minFallingPathSum(vector&lt;vector&lt;int>>&amp; grid) { int n=grid.size(); int f[n][n]; int g[n*n]; int count=0; for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;n;j++) { if(i==0) f[i][j]=grid[i][j]; else { int min=INT_MAX; int wih; for(int wht=0;wht&lt;n;wht++) { if(wht==j) continue; else if(f[i-1][wht]&lt;min) {min=f[i-1][wht];wih=wht;} } f[i][j]=min+grid[i][j]; g[getId(i,j,n)]=getId(i-1,wih,n); } /*else if(j==0) f[i][j]=f[i-1][j+1]+grid[i][j];//rht else if(j==n-1) f[i][j]=f[i-1][j-1]+grid[i][j];//left else { int left=f[i-1][j-1]+grid[i][j]; int rht=f[i-1][j+1]+grid[i][j]; f[i][j]=min(left,rht); } */ } } //find min int min=INT_MAX; int num; for(int i=0;i&lt;n;i++) { if(f[n-1][i]&lt;min) { min=f[n-1][i]; num=i; } } //print(reverse) int row; int col; count=0; while(count&lt;n) { int id; if(count==0) { id=getId(n-1,num,n); row=getRow(id,n); col=getCol(id,n); cout&lt;&lt;grid[row][col]&lt;&lt;\" \"; } else { id=g[id]; row=getRow(id,n); col=getCol(id,n); cout&lt;&lt;grid[row][col]&lt;&lt;\" \"; } count++; } return min; } }; /* 输出：看懂别人写的和自己复现是完全不一样的 错误：真的不知道哪里出错，也遇到了评论区的问题“自己进入了个思路误区： dp[i][j] 更新为了上一层对应得坐标加上当前层得最小值， 正确得应该是上一层得最小值， 加上当前层的值得最小更新dp[i][j]”，但改了还是出错，和原来没区别 好吧，题目理解错了，不是只能取相邻的点 反思：忘记了前几天的滚动数组，果然还是不能偷懒，要用hexo记录 */ 原作者宫水三叶的解析如何简化这个问题？同样按照上一道题的步骤首先拆分解法的步骤1、DP状态转移，共需转移n*n个状态2、转移时需要枚举上一行的所有列因为DP无法优化，所以只能优化第二步。那怎么优化枚举呢细想就可以发现，当我们在计算某行的状态值的时候，只会用到「上一行」的两个值:最小值和次小值。因为我们只需要最小和，但考虑到前后元素不能有相同的列数，所以当前[i,j]位置最小的路径只考虑最小值和次小值即可 看对应代码 class Solution { public: int minFallingPathSum(vector&lt;vector&lt;int>>&amp; grid) { int n = grid.size(); if(n == 1) return grid[0][0]; vector&lt;vector&lt;int>> dp(n, vector&lt;int>(n)); // (i,j)位置在原问题的解 int pos1 = -1, pos2 = -1; //上一行最小及次小值所在的列 for(int i = 0; i &lt; n; i++){ dp[0][i] = grid[0][i]; if(dp[0][i] &lt;= (pos1 == -1 ? INT_MAX : dp[0][pos1])){ //当前值小于等于最小值时,同时更新pos1和pos2 pos2 = pos1; //此处应该先更新pos2,然后更新pos1 pos1 = i; } else if(dp[0][i] &lt; (pos2 == -1 ? INT_MAX : dp[0][pos2])){ //当前值大于最小值,小于次小值时,更新pos2 pos2 = i; } } for(int i = 1; i &lt; n; i++){ for(int j = 0; j &lt; n; j++){ dp[i][j] = (j != pos1 ? dp[i-1][pos1] : dp[i-1][pos2]) + grid[i][j]; } pos1 = -1, pos2 = -1; //需重置 计算当前行数字和最小及次小所在的列 for(int j = 0; j &lt; n; j++){ if(dp[i][j] &lt;= (pos1 == -1 ? INT_MAX : dp[i][pos1])){ pos2 = pos1; pos1 = j; } else if(dp[i][j] &lt; (pos2 == -1 ? INT_MAX : dp[i][pos2])){ pos2 = j; } } } return dp[n-1][pos1]; } }; //感谢热心作者：秦时明月 //链接：https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/r8obm3/?discussion=rQGrX1","categories":[{"name":"C++基础","slug":"C-基础","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/LeetCode/"},{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/C/"},{"name":"DP","slug":"DP","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/DP/"}]},{"title":"微信文件过期solution","slug":"微信文件过期solution","date":"2022-09-09T16:09:18.000Z","updated":"2022-09-21T12:49:38.843Z","comments":true,"path":"2022/09/10/微信文件过期solution/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/10/%E5%BE%AE%E4%BF%A1%E6%96%87%E4%BB%B6%E8%BF%87%E6%9C%9Fsolution/","excerpt":"微信文件过期了怎么办？急急急急急。。","text":"cr.豆瓣句号小组 **方法2** 【ps】由于句号组的帖子很容易殉o(╥﹏╥)o，所以都截图保存了感谢原作者桃子老师的分享~","categories":[{"name":"生活","slug":"生活","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"豆瓣","slug":"豆瓣","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E8%B1%86%E7%93%A3/"},{"name":"实用技巧","slug":"实用技巧","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"生活","slug":"生活","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"DP Day2","slug":"DP-Day2","date":"2022-09-06T14:02:27.000Z","updated":"2022-09-21T12:58:19.378Z","comments":true,"path":"2022/09/06/DP-Day2/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/06/DP-Day2/","excerpt":"DP“最小路径和”问题","text":"第一题给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。链接：https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/rtcz3i/ 思路大致和DP1的思想一致：1、先定义状态f[m][n]2、找出状态转移函数ps.最重要的就是搞清楚状态定义！！f[m][n]意味着什么？f[m-1][n]又意味着什么？它们之间的关系为什么是这样？搞清楚状态定义基本上解决了这种题目。比较简单，直接看代码吧 class Solution { public: int minPathSum(vector&lt;vector&lt;int>>&amp; grid) { int m=grid.size(); int n=grid[0].size(); int f[m][n];//到(m+1,n+1)点的总长度 f[0][0]=grid[0][0]; for(int i=0;i&lt;m;i++) { for(int j=0;j&lt;n;j++) { if(i>0&amp;&amp;j>0) { if(f[i][j-1]>=f[i-1][j]) f[i][j]=f[i-1][j]+grid[i][j]; else f[i][j]=f[i][j-1]+grid[i][j]; } else if(i>0) f[i][j]=f[i-1][j]+grid[i][j]; else if(j>0) f[i][j]=f[i][j-1]+grid[i][j]; } } return f[m-1][n-1]; } }; 原作者宫水三叶的解析作者希望通过「最小路径和」问题来分享如何进行「维度合并」来降低“出错风险”和“Debug 难度”。这是 DP 问题中的一个常用技巧：通过「问题等价变换」来降低编码难度。这道题也不难，为什么需要等价变换呢？作者在进阶版中，输出了总和最低的路径，输出路径可以便于程序员以及参考代码者查看相关路径，便于debug而原做法是顺序推导的,那么在寻找最短路径的过程中，到不同节点的最短路径index也是顺序存储的但是由于最短路径可能多于1条，所以我们不能直接在存储路径index的数组顺序读取需要输出的路径那么我们只能倒序读取，而倒序读取必然需要新的数组存储数值，因为我们要正序输出新的数组就会消耗更多空间因此，我们可以「问题等价变换」 作者的解决办法：1、倒推从终点倒推到起点2、信息存储使用「一维数组」存储「二维信息」，这是一个常见的手段。一维数组：idx的函数，我们可以通过函数得出idx的行和列二维信息：路径点的行和列 由于之后还有类似的题目所以自己没有写输出路径的代码，以下是热心同学sheepice写的cpp代码： #include&lt;bits/stdc++.h> using namespace std; int m, n; //m代表行，n代表列 int row(int idx) { //取得所在行 return idx / n; } int col(int idx) { //取得所在列 return idx % n; } int getidx(int x, int y) { //得到每一个一维坐标 return x * n + y; } int main() { cin >> m >> n; vector&lt; vector&lt;int> > grid(m, vector&lt;int>(n,0)); vector&lt; vector&lt;int> > dp(m, vector&lt;int>(n,0)); vector&lt;int> vis(m * n, 0); for(int i =0; i &lt; m; i ++) { //进行数组的输入； for(int j = 0; j &lt; n; j++) { cin >> grid[i][j]; } } //因为要进行路径的输出，因此我们的dp路径从后往前 /* //先进行初始化,但是这样的初始化是不适合找路径的，因为 并没有在这个初始化的过程中记录下来我们的最短路径 dp[m - 1][n - 1] = grid[m - 1][n - 1]; for(int i = m - 2; i >= 0; i--) { dp[i][n - 1] = dp[i + 1][n - 1] + grid[i][n - 1]; } for(int i = n - 2; i>=0; i--) { dp[m - 1][i] = dp[m - 1][i + 1] + grid[m - 1][i]; } */ //开始进行从后往前的递推，并且推的过程记录下来我们的最短路径 for(int i = m - 1; i >= 0; i--) { for(int j = n - 1; j >= 0; j--) { if(i == m - 1 &amp;&amp; j == n - 1) { dp[m - 1][n - 1] = grid[m - 1][n - 1]; } else { int bot = i + 1 &lt; m ? grid[i][j] + dp[i + 1][j] : INT_MAX; int rht = j + 1 &lt; n ? grid[i][j] + dp[i][j + 1] : INT_MAX; dp[i][j] = min(bot, rht); vis[getidx(i, j)] = bot &lt; rht ? getidx(i + 1,j) : getidx(i, j + 1); } } } int idx = getidx(0, 0); cout &lt;&lt; \"最短的路径为：\" &lt;&lt; endl; for(int i = 1; i &lt; m + n - 1; i++) { cout &lt;&lt; \"(\" &lt;&lt; row(idx) &lt;&lt; \",\" &lt;&lt; col(idx) &lt;&lt; \")->\"; idx = vis[idx]; } cout &lt;&lt; \"(\" &lt;&lt; row(idx) &lt;&lt; \",\" &lt;&lt; col(idx) &lt;&lt; \")\" &lt;&lt; endl; cout &lt;&lt;\"最短的路径和为:\" &lt;&lt; endl; cout &lt;&lt; dp[0][0] &lt;&lt; endl; } //作者：sheepice //链接：https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/rtb68e/?discussion=d2e6U2 //来源：力扣（LeetCode） 第二题给定一个三角形 triangle ，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1作者：宫水三叶，相关链接 初始思路1、使用dp[i][j]存储到[i][j]点的路径和最终要求：i=m-1,j没有要求在运动过程中j始终&lt;=i2、使用二维数组f进行路径记录，f[index[dp]][line]index[dp]表示哪一条路，line表示哪一层不过由于路径多，如何唯一表示index？能不能按累加定义index？。。。然后就卡住了😅。。 没办法了，仔细看了上一题的解析终于知道为什么从后往前推更方便。。。因为只存储最短路径（1条）的idx所以从后往前推，不然得先存在一个数组里再输出（浪费空间）。。不过三角形怎么从idx推出在哪一行哪一列、、、要不开一个一维数组存储三角形的值算了、、、tri完蛋，还是不会记录，不过三角形倒推就没有正推的问题因为从下往上是唯一的，从上往下是不唯一的然后写出来了下面的东西 class Solution { public: int minimumTotal(vector&lt;vector&lt;int>>&amp; triangle) { int idx=0;//一维三角形数组的idx int line=triangle.size(); int tri[(line+1)*line/2]; for(int row=0;row&lt;line;row++) { for(int col=0;col&lt;=row;col++) { tri[idx]=triangle[row][col]; idx++; } }//以上的最后没用上，是原来想输出路径（failed）写的 int dp[line][line]; memset(dp,0,sizeof(dp)); for(int i=line-1;i>=0;i--) { for(int j=i;j>=0;j--) { if(i==line-1) dp[i][j]=triangle[i][j]; else { int up,ulft; //up=(j!=i)?dp[i+1][j]+triangle[i][j]:INT_MAX; //ulft=(j!=0)?dp[i+1][j+1]+triangle[i][j]:INT_MAX; up=dp[i+1][j]+triangle[i][j]; ulft=dp[i+1][j+1]+triangle[i][j]; dp[i][j]=min(up,ulft); } } } return dp[0][0]; } }; 最后看评论，如何节约空间的方法：因为对状态是如何转移不感兴趣，程序员在调试的时候感兴趣（debug）由于用户不感兴趣，因此可以直接在原三角形上更改（？有点危险 作者解析本题是否可以使用DP解决，要分析有无后效性首先，既然是从上到下的路径，那么最后一个点必然是落在最后一行。对于最后一行的某个位置的值，根据题意只能从上一行的某一个位置或者某两个位置之一转移而来。同时，我们只关注前一位的累加值是多少，而不关心这个累加值结果是由什么路径而来的。这显然就满足了「无后效性」的定义：我们转移某个状态需要用到某个值，但是并不关心该值是如何而来的。更加的学术表达是：当前某个状态确定后，之后的状态转移与之前的决策无关 既然可以使用DP解决该问题，那么我们就需要定义「DP状态」： f[i][j]代表到达某个点的最小路径和状态转移：1、每一行 i 具有 i+1 个数字2、只要不是第一列（j!=0）位置上的数，都能通过「左上方」转移过来3、只要不是每行最后一列（j!=i）位置上的数，都能通过「上方」转移而来 class Solution { public int minimumTotal(List&lt;List&lt;Integer>> tri) { int n = tri.size(); int ans = Integer.MAX_VALUE; int[][] f = new int[n][n]; f[0][0] = tri.get(0).get(0); for (int i = 1; i &lt; n; i++) { for (int j = 0; j &lt; i + 1; j++) { int val = tri.get(i).get(j); f[i][j] = Integer.MAX_VALUE; if (j != 0) f[i][j] = Math.min(f[i][j], f[i - 1][j - 1] + val); if (j != i) f[i][j] = Math.min(f[i][j], f[i - 1][j] + val); } } for (int i = 0; i &lt; n; i++) ans = Math.min(ans, f[n - 1][i]); return ans; } } 进阶递推过程可以发现，在求第 i 行的状态时只依赖于第 i-1 行的状态。那么我们不需要存储所有行的状态值（动规值），可以对空间进行优化。 DP 空间优化技巧 1、滚动数组 2、根据状态依赖调整迭代/循环的方向 **滚动数组**没有任何的思维难度，只需要将其中一维直接改成 2， 将维的 f[i] 改成 f[i&amp;1] 或者 f[i%2] 即可（推荐前者，在不同架构的机器上，运算效率更加稳定）。 这样数组仅存储两行的内容，用完的数据就被覆盖掉 ```java class Solution { public int minimumTotal(List","categories":[{"name":"C++基础","slug":"C-基础","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/LeetCode/"},{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/C/"},{"name":"DP","slug":"DP","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/DP/"}]},{"title":"DP Day1","slug":"DP-Day1","date":"2022-09-06T14:02:04.000Z","updated":"2022-09-21T12:57:57.172Z","comments":true,"path":"2022/09/06/DP-Day1/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/06/DP-Day1/","excerpt":"DP最基础的“不同路径”问题","text":"第一题一个机器人位于一个 m x n&nbsp;网格的左上角 （起始点在下图中标记为 “Start” ）机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？链接：https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/rtwu06/ 初步的思路：3*7的地图，只能向右或者向下，总共走8步可以到终点，那么就要考虑右和下这两个动作在向量里的位置。如下图所示，需要向右6步，向下2步，那么就计算2个下元素在向量中的位置（无序）。 第一个“下”的位置 第二个“下”的可能 0 7 1 6 2 5 。。 。。 6 1 最后求和，得7*8/2=28不过这种思路很难找到通用的公式（哭） 直接看解析！有人使用递归来解决，递归的关键是1.找到函数关系（把范围变小）2.找到递归结束条件对于这道题来说，范围变小：每移动一步，地图就变小了 本讲重要知识点动态规划（DP）是什么？若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。以下是作者宫水三叶对原题的分析定义 f[i][j]f[i][j] 为到达位置 (i,j)(i,j) 的不同路径数量。那么 f[m-1][n-1]f[m−1][n−1] 就是我们最终的答案，而 f[0][0] = 1是一个显而易见的起始条件。由于题目限定了我们只能往下或者往右移动，因此我们按照当前可选方向进行分析：当前位置只能「往下」移动，即有 f[i][j] = f[i-1][j]当前位置只能「往右」移动，即有 f[i][j] = f[i][j-1]当前位置即能「往下」也能「往右」移动，即有 f[i][j] = f[i][j-1] + f[i-1][j] 因为是好久没接触DP类型的题目，基本忘光，这里直接搬上作者对于这道题的总结 我们是如何确定本题可以使用动态规划来解决的？通常我们要从「有无后效性」进行入手分析。如果对于某个状态，我们可以只关注状态的值，而不需要关注状态是如何转移过来的话，那么这就是一个无后效性的问题，可以考虑使用 DP 解决。另外一个更加实在的技巧，我们还可以通过数据范围来猜测是不是可以用 DP来做。因为DP是一个递推的过程，因此如果数据范围是 10^5~10^6 的话，可以考虑是不是可以使用一维 DP来解决；如果数据范围是 10^2~10^3 的话，可以考虑是不是可以使用二维 DP 来做 … 我们是如何确定本题的状态定义的？说实话，DP 的状态定义很大程度是靠经验去猜的。虽然大多数情况都是猜的，但也不是毫无规律，相当一部分题目的状态定义是与「结尾」或「答案」有所关联 我们是如何确定状态转移方程的？通常来说，如果我们的状态定义猜对了，状态转移方程就是对「最后一步的分情况讨论」。如果我们有一个对的状态定义的话，基本上状态转移方程就是呼之欲出。因此一定程度上，状态转移方程可以反过来验证我们状态定义猜得是否正确：如果猜了一个状态定义，然后发现无法列出涵盖所有情况（不漏）的状态转移方程，多半就是状态定义猜错了，赶紧换个思路，而不是去死磕状态转移方程。 对状态转移的要求是什么？我们的状态转移是要做到「不漏」还是「不重不漏」取决于问题本身：如果是求最值的话，我们只需要确保「不漏」即可，因为重复不影响结果。如果是求方案数的话，我们需要确保「不重不漏」。 我们是如何分析动态规划的时间复杂度的？对于动态规划的复杂度/计算量分析，有多少个状态，复杂度/计算量就是多少。因此一维DP的复杂度通常是线性的 O(n) ，而二维DP的复杂度通常是平方的 O(n^2)。 第二题一个机器人位于一个&nbsp;m x n&nbsp;网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。 第二题是对第一题的巩固，就自己按第一题的思路做了一下。以下是自己写的代码，注释是当时的思路和错误的地方： class Solution { public: int uniquePathsWithObstacles(vector&lt;vector&lt;int>>&amp; obstacleGrid) { int i; int m = obstacleGrid.size(); int n = obstacleGrid[i].size(); int f[m][n]; //memset(f,-1,sizeof(f));//加不加对编译没有影响，但不初始化很危险 f[0][0]=(obstacleGrid[0][0]==0)?1:0;//漏初始条件 for(int i=0;i&lt;m;i++) { for(int j=0;j&lt;n;j++) { if(obstacleGrid[i][j]==1) f[i][j]=0; if(obstacleGrid[i][j]==0) { if(i>0&amp;&amp;j>0) f[i][j]=f[i-1][j]+f[i][j-1]; else if(i>0) f[i][j]=f[i-1][j];//右，注意条件，j=0表示只能向右 else if(j>0) f[i][j]=f[i][j-1];//下 } } } return f[m-1][n-1]; } }; //f[i][j]: //1,o[i-1][j]=1--f[i][j]=f[i][j-1] //2,o[i][j-1]=1--f[i][j]=f[i-1][j] //3,o[i-1][j-1]=0--f[i][j]=f[i][j-1]+f[i-1][j] //4,o[i-1][j-1]=1--f[i][j]=0 //一开始的构思，漏洞百出。。。 //注意vector的格式，二维数组初始化 //一定要清晰定义f[m][n] //当前的状态去推导下一时刻状态，因此不管怎么样等式右边都是x-m（表示过去）的形式，等式左边就是x（当前）","categories":[{"name":"C++基础","slug":"C-基础","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/C-%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/LeetCode/"},{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/C/"},{"name":"DP","slug":"DP","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/DP/"}]},{"title":"累了就休息一下，看一点人间喜剧","slug":"累了就休息一下，看一点人间喜剧","date":"2022-09-04T09:01:52.000Z","updated":"2022-09-15T12:09:39.572Z","comments":true,"path":"2022/09/04/累了就休息一下，看一点人间喜剧/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/04/%E7%B4%AF%E4%BA%86%E5%B0%B1%E4%BC%91%E6%81%AF%E4%B8%80%E4%B8%8B%EF%BC%8C%E7%9C%8B%E4%B8%80%E7%82%B9%E4%BA%BA%E9%97%B4%E5%96%9C%E5%89%A7/","excerpt":"很有意思的社死相关帖子","text":"叔叔你别拉了，我害怕推荐理由：作者语言描述能力惊人，画面感十足 封校期间在QQ上被QQ自动回复社死推荐理由：很有意思的自动回复格式，激发没有幽默感的我的灵感 没想到被一个❤尬住了推荐理由：。。。。sorry因为这颗❤我笑出了眼泪 失手把狗狗照片发进工作群，而工作群正在。。。推荐理由：what a coincidence 为了吵架更有气势改名字，结果打错了字推荐理由：豆瓣的提示，蛮有意思的，正经中带着一丝丝粗鲁 朋友误以为我买了gang塞推荐理由：本来以为不喜欢这种段子，没想到被lz的朋友温暖到了😭","categories":[{"name":"乐一乐","slug":"乐一乐","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/%E4%B9%90%E4%B8%80%E4%B9%90/"}],"tags":[{"name":"豆瓣","slug":"豆瓣","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E8%B1%86%E7%93%A3/"},{"name":"社死","slug":"社死","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E7%A4%BE%E6%AD%BB/"}]}],"categories":[{"name":"C++基础","slug":"C-基础","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/C-%E5%9F%BA%E7%A1%80/"},{"name":"-电子电路","slug":"电子电路","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/"},{"name":"C++项目","slug":"C-项目","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/C-%E9%A1%B9%E7%9B%AE/"},{"name":"生活","slug":"生活","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/%E7%94%9F%E6%B4%BB/"},{"name":"乐一乐","slug":"乐一乐","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/%E4%B9%90%E4%B8%80%E4%B9%90/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/LeetCode/"},{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/C/"},{"name":"栈","slug":"栈","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E6%A0%88/"},{"name":"队列","slug":"队列","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E9%98%9F%E5%88%97/"},{"name":"-电路","slug":"电路","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E7%94%B5%E8%B7%AF/"},{"name":"debug","slug":"debug","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/debug/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/DFS/"},{"name":"豆瓣","slug":"豆瓣","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E8%B1%86%E7%93%A3/"},{"name":"心理学","slug":"心理学","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"},{"name":"markdown","slug":"markdown","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/markdown/"},{"name":"DP","slug":"DP","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/DP/"},{"name":"实用技巧","slug":"实用技巧","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"生活","slug":"生活","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"社死","slug":"社死","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E7%A4%BE%E6%AD%BB/"}]}