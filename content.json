{"meta":{"title":"Eloise Wang","subtitle":"Eloise的记事本","description":"","author":"Eloise_W","url":"https://Harper00vv00/Harper00vv00.github.io","root":"/"},"pages":[{"title":"categories","date":"2022-09-04T15:27:32.000Z","updated":"2022-09-04T15:28:29.097Z","comments":true,"path":"categories/index.html","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2022-09-04T15:13:32.000Z","updated":"2022-09-04T15:20:18.960Z","comments":true,"path":"about/index.html","permalink":"https://harper00vv00/Harper00vv00.github.io/about/index.html","excerpt":"","text":"profile: avater: #头像 career: 打工人 introduction： 一技之长，衣食无忧 my Projects: enable: false my Skills: enable: true data: cpp: background: ‘linear-gradient(to right, #9900FF 0%, #CC66FF 100%)’ percent: 80% my Gallery: #相册 enable: false"},{"title":"contact","date":"2022-09-04T15:26:34.000Z","updated":"2022-09-04T15:28:51.838Z","comments":true,"path":"contact/index.html","permalink":"https://harper00vv00/Harper00vv00.github.io/contact/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-09-04T15:26:50.000Z","updated":"2022-09-04T15:29:12.928Z","comments":true,"path":"friends/index.html","permalink":"https://harper00vv00/Harper00vv00.github.io/friends/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-09-04T15:20:33.000Z","updated":"2022-09-04T15:21:33.872Z","comments":true,"path":"tags/index.html","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"DP-Day4","slug":"DP-Day4","date":"2022-09-15T11:44:18.000Z","updated":"2022-09-15T11:50:40.907Z","comments":true,"path":"2022/09/15/DP-Day4/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/15/DP-Day4/","excerpt":"统计所有可行路径","text":"第一题给你一个互不相同的整数数组，其中&nbsp;locations[i]&nbsp;表示第&nbsp;i&nbsp;个城市的位置。同时给你&nbsp;start，finish&nbsp;和&nbsp;fuel&nbsp;分别表示出发城市、目的地城市和你初始拥有的汽油总量每一步中，如果你在城市 i&nbsp;，你可以选择任意一个城市 j&nbsp;，满足 &nbsp;j != i&nbsp;且&nbsp;0 &lt;= j &lt; locations.length&nbsp;，并移动到城市&nbsp;j&nbsp;。从城市&nbsp;i&nbsp;移动到&nbsp;j&nbsp;消耗的汽油量为&nbsp;|locations[i] - locations[j]|，|x|&nbsp;表示&nbsp;x&nbsp;的绝对值。请注意，&nbsp;fuel&nbsp;任何时刻都&nbsp;不能&nbsp;为负，且你&nbsp;可以&nbsp;经过任意城市超过一次（包括&nbsp;start&nbsp;和&nbsp;finish&nbsp;）。请你返回从&nbsp;start&nbsp;到&nbsp;finish&nbsp;所有可能路径的数目。由于答案可能很大， 请将它对&nbsp;10^9 + 7&nbsp;取余后返回。链接在这里 原思路定义变量：b、e分别表示每一次移动的起点与终点，每次移动step步 对比作者的思路路径问题-&gt;DFS-&gt;DFS问题为指数级别复杂度-&gt;记忆化搜索 实现DFS的通常步骤1、设计好递归函数的「入参」和「出参」2、设置好递归函数的出口（Base Case）3、编写「最小单元」处理逻辑其中，最重要的是要找出Base Case，也就是确定在什么情况下，算一次有效/无效本题的有效情况：当前所在位置为finish本题无效情况：1、油量消耗完，且当前位置不在finish 2、油量不为0，但无法移动到任何位置接着，添加记忆化搜索记忆化搜索就是使用变量（通常是数组）记录当前状态，也就是中间结果我们用 cache[i][fuel] 代表从位置 i 出发，当前剩余的油量为 fuel 的前提下，到达目标位置的「路径数量」。之所以能采取「缓存中间结果」这样的做法，是因为「在 i 和 fuel 确定的情况下，其到达目的地的路径数量是唯一确定的」。与自己的思路区别：作者的中间状态（最小单元）有2个变量：fuel和起点，也就是自己定义的step和b比自己定义的中间状态少了一个变量自己定义的三维数组存储的是是否存在路径*而作者定义的二维数组存储了成立的路径数量我想作者如此定义中间状态的原因主要参考了本题的有效情况（到达finish）和所需output所以以后定义中间状态变量时遇到维度过多的情况，可以考虑使用“数量”代替“存在”，利用变量的取值减少一个维度* DFS（深度优先搜索）的框架 function dfs(当前状态){ if(当前状态 == 目的状态){ ··· } for(···寻找新状态){ if(状态合法){ vis[访问该点]； dfs(新状态); ?是否需要恢复现场-&gt;vis[恢复访问] } } if(找不到新状态){ ··· } } //CSDN博主「HeartFireY」的原创文章 //原文链接：https://blog.csdn.net/yanweiqi1754989931/article/details/109603384 //制作很精美的博文（DFS介绍） 作者宫水三叶的代码 class Solution { int mod = 1000000007; // 缓存器：用于记录「特定状态」下的结果 // cache[i][fuel] 代表从位置 i 出发，当前剩余的油量为 fuel 的前提下，到达目标位置的「路径数量」 int[][] cache; public int countRoutes(int[] ls, int start, int end, int fuel) { int n = ls.length; // 初始化缓存器 // 之所以要初始化为 -1 // 是为了区分「某个状态下路径数量为 0」和「某个状态尚未没计算过」两种情况 cache = new int[n][fuel + 1]; for (int i = 0; i &lt; n; i++) { Arrays.fill(cache[i], -1); } return dfs(ls, start, end, fuel); } /** * 计算「路径数量」 * @param ls 入参 locations * @param u 当前所在位置（ls 的下标） * @param end 目标哦位置（ls 的下标） * @param fuel 剩余油量 * @return 在位置 u 出发，油量为 fuel 的前提下，到达 end 的「路径数量」 */ int dfs(int[] ls, int u, int end, int fuel) { // 如果缓存器中已经有答案，直接返回————记忆化搜索 if (cache[u][fuel] != -1) { return cache[u][fuel]; } int n = ls.length; // base case 1：如果油量为 0，且不在目标位置 // 将结果 0 写入缓存器并返回 if (fuel == 0 &amp;&amp; u != end) { cache[u][fuel] = 0; return 0; } // base case 2：油量不为 0，且无法到达任何位置 // 将结果 0 写入缓存器并返回 boolean hasNext = false; for (int i = 0; i &lt; n; i++) { if (i != u) { int need = Math.abs(ls[u] - ls[i]); if (fuel >= need) { hasNext = true; break; } } } if (fuel != 0 &amp;&amp; !hasNext) { cache[u][fuel] = u == end ? 1 : 0; return cache[u][fuel]; } // 计算油量为 fuel，从位置 u 到 end 的路径数量 // 由于每个点都可以经过多次，如果 u = end，那么本身就算一条路径 int sum = u == end ? 1 : 0; for (int i = 0; i &lt; n; i++) { if (i != u) { int need = Math.abs(ls[i] - ls[u]); if (fuel >= need) { sum += dfs(ls, i, end, fuel - need); sum %= mod; } } } cache[u][fuel] = sum; return sum; } } 简化Base Case简化Base Case就是要深入挖掘有/无效情况原先定义的无效情况：下一步（是一步）无法达到finish其实，如果当前位置经计算无法达到finish，那么任移动几步都无法达到finish代码变化： // 如果一步到达不了，说明从位置 u 不能到达 end 位置 // 将结果 0 写入缓存器并返回 int need = Math.abs(ls[u] - ls[end]); if (need > fuel) { cache[u][fuel] = 0; return 0; } //上述代码将替换原先两个Base Case 进阶:动态规划求解❓如何将本题使用动态规划的方式求解？任何「记忆化搜索」都能改成「动态规划」。 如何直接将「记忆化搜索」改成「动态规划」。 使用这种技巧，你将不需要去猜「状态定义」和根据「状态定义」推导「状态转移方程」。 1、关注DFS函数的参数 ``` int dfs(int[] ls, int u, int end, int fuel) {} ``` 其中，ls(location)和end(finish)在DFS过程中不会改变 而u和fuel分别表示当前位置和当前油量，是可变参数 那么，定义二维数组f，分别表示两个可变参数 第一维代表当前位置，第二维代表剩余油量 数组存储DFS的返回值（路径数量） 2、翻译出「状态转移方程」第一步的“翻译”工作后，我们得到了「动态规划」的「状态定义」。所谓的「状态转移方程」其实就是指如何从一个状态转移到另外一个状态。而我们的 DFS 主逻辑就是完成这个转移的。DFS 中的主逻辑很简单：枚举所有的位置，看从当前位置 u 出发，可以到达的位置有哪些。于是我们很容易就可以得出状态转移方程：f[i][fuel]=f[i][fuel]+f[k][fuel-need]k 代表计算位置 i 油量 fuel 的状态时枚举的「下一位置」，need 代表从 i 到达 k 需要的油量。 i 和 k 并无严格的大小关系，而 fuel 和 fuel-need 具有严格的大小关系（fuel ≥ fuel−need）。因此我们需要先从小到大枚举油量这一维。 int mod = 1000000007; public int countRoutes(int[] ls, int start, int end, int fuel) { int n = ls.length; // f[i][j] 代表从位置 i 出发，当前油量为 j 时，到达目的地的路径数 int[][] f = new int[n][fuel + 1]; // 对于本身位置就在目的地的状态，路径数为 1 for (int i = 0; i &lt;= fuel; i++) f[end][i] = 1; // 从状态转移方程可以发现 f[i][fuel]=f[i][fuel]+f[k][fuel-need] // 在计算 f[i][fuel] 的时候依赖于 f[k][fuel-need] // 其中 i 和 k 并无严格的大小关系 // 而 fuel 和 fuel-need 具有严格大小关系：fuel >= fuel-need // 因此需要先从小到大枚举油量 for (int cur = 0; cur &lt;= fuel; cur++) { for (int i = 0; i &lt; n; i++) { for (int k = 0; k &lt; n; k++) { if (i != k) { int need = Math.abs(ls[i] - ls[k]); if (cur >= need) { f[i][cur] += f[k][cur-need]; f[i][cur] %= mod; } } } } } return f[start][fuel]; } } //作者：宫水三叶 //链接：https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/r8n0h2/ 总结整个过程：1、从 DFS 方法签名出发。分析哪些入参是可变的，将其作为 DP 数组的维度；将返回值作为 DP 数组的存储值。2、从 DFS 的主逻辑可以抽象中单个状态的计算方法。 其中第一点对应了「动态规划」的「状态定义」，第二点对应了「动态规划」的「状态方程转移」。 作者对这几章练习的小结两种求解「动态规划」问题的方法：1、根据经验猜一个「状态定义」，然后根据「状态定义」去推导一个「状态转移方程」。2、先写一个「记忆化搜索」解法，再将「记忆化搜索」改写成「动态规划」。 能够去猜「状态定义」或者使用「记忆化搜索」求解，都有一个大前提：问题本身具有无效性。 如果遇到一道你从来没接触过的题目时，建议先想想「记忆化搜索」该如何实现，然后反推出「动态规划」。这里说的想想「记忆化搜索」该如何实现，不需要真正动手实现一个「记忆化搜索」解法，而只需要想清楚，如果使用「记忆化搜索」的话，我的 DFS 函数参数和返回值如何设计即可。","categories":[{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/C/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/LeetCode/"},{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/C/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/DFS/"}]},{"title":"DP-Day3","slug":"DP-Day3","date":"2022-09-14T11:49:44.000Z","updated":"2022-09-14T12:36:33.128Z","comments":true,"path":"2022/09/14/DP-Day3/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/14/DP-Day3/","excerpt":"下降路径最小和","text":"第一题给你一个 n x n 的方形整数数组&nbsp;matrix ，请你找出并返回通过 matrix 的下降路径的最小和。下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。链接在这里！ 思路：蛮简单的感觉，用上一道题的方法，直接更改matrix，节约空间（但是直接更改原数据十分危险） class Solution { public: int minFallingPathSum(vector&lt;vector&lt;int>>&amp; matrix) { int m=matrix.size();//矩阵的行、列 for(int i=1;i&lt;m;i++) { for(int j=0;j&lt;m;j++) { int lft,mid,rht; lft=(j!=0)?matrix[i-1][j-1]+matrix[i][j]:INT_MAX; mid=matrix[i-1][j]+matrix[i][j]; rht=(j!=m-1)?matrix[i-1][j+1]+matrix[i][j]:INT_MAX; matrix[i][j]=min(lft,mid); matrix[i][j]=min(matrix[i][j],rht); } } //找到最后一行最小的路径值 int ans=INT_MAX; for(int i=0;i&lt;m;i++) { ans=min(ans,matrix[m-1][i]); } return ans; } }; 原作者宫水三叶的解析其实细看可以发现，自己的解法相当于作者动态规划（基于定义）的解法还有一个复杂度较高的解法： 基于起点解法的原理：起点任选，每一个起点都存在最小路径，那么相当于把问题拆分成两步1、找到一个起点u的最小路径——find函数2、遍历所有找到的最小路径，找出最小点——for(遍历所有u){find(u,)}整套算法时间复杂度O(n^3) 那么就从理论上学习一下自己写的代码吧！动态规划（基于定义）观察上一个解法的步骤：1、枚举起点 2、DP求最小路径和(find函数)DP的复杂程度无法优化，那么我们选择优化枚举的过程 直接从 DP 定义出发，进行转移即可。定义 f[i][j]为到达位置 (i,j) 的最小路径和。那么最终答案为所有 f[n-1][i]的最小值，i的取值范围为 [0,n)。代表最小路径的结尾可能是最后一行的任意位置。 第二题给你一个&nbsp;n x n 整数矩阵&nbsp;arr&nbsp;，请你返回 非零偏移下降路径 数字和的最小值。非零偏移下降路径 定义为：从&nbsp;arr 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。 代码最后的注释包含了本人做这题的心路历程，其实这题很简单 class Solution { public: int getId(int x,int y,int n) { return x*n+y; } int getRow(int x,int n) { return x/n;//注意整除符号不要写成转义符号！ } int getCol(int x,int n) { return x%n; } int minFallingPathSum(vector&lt;vector&lt;int>>&amp; grid) { int n=grid.size(); int f[n][n]; int g[n*n]; int count=0; for(int i=0;i&lt;n;i++) { for(int j=0;j&lt;n;j++) { if(i==0) f[i][j]=grid[i][j]; else { int min=INT_MAX; int wih; for(int wht=0;wht&lt;n;wht++) { if(wht==j) continue; else if(f[i-1][wht]&lt;min) {min=f[i-1][wht];wih=wht;} } f[i][j]=min+grid[i][j]; g[getId(i,j,n)]=getId(i-1,wih,n); } /*else if(j==0) f[i][j]=f[i-1][j+1]+grid[i][j];//rht else if(j==n-1) f[i][j]=f[i-1][j-1]+grid[i][j];//left else { int left=f[i-1][j-1]+grid[i][j]; int rht=f[i-1][j+1]+grid[i][j]; f[i][j]=min(left,rht); } */ } } //find min int min=INT_MAX; int num; for(int i=0;i&lt;n;i++) { if(f[n-1][i]&lt;min) { min=f[n-1][i]; num=i; } } //print(reverse) int row; int col; count=0; while(count&lt;n) { int id; if(count==0) { id=getId(n-1,num,n); row=getRow(id,n); col=getCol(id,n); cout&lt;&lt;grid[row][col]&lt;&lt;\" \"; } else { id=g[id]; row=getRow(id,n); col=getCol(id,n); cout&lt;&lt;grid[row][col]&lt;&lt;\" \"; } count++; } return min; } }; /* 输出：看懂别人写的和自己复现是完全不一样的 错误：真的不知道哪里出错，也遇到了评论区的问题“自己进入了个思路误区： dp[i][j] 更新为了上一层对应得坐标加上当前层得最小值， 正确得应该是上一层得最小值， 加上当前层的值得最小更新dp[i][j]”，但改了还是出错，和原来没区别 好吧，题目理解错了，不是只能取相邻的点 反思：忘记了前几天的滚动数组，果然还是不能偷懒，要用hexo记录 */ 原作者宫水三叶的解析如何简化这个问题？同样按照上一道题的步骤首先拆分解法的步骤1、DP状态转移，共需转移n*n个状态2、转移时需要枚举上一行的所有列因为DP无法优化，所以只能优化第二步。那怎么优化枚举呢细想就可以发现，当我们在计算某行的状态值的时候，只会用到「上一行」的两个值:最小值和次小值。因为我们只需要最小和，但考虑到前后元素不能有相同的列数，所以当前[i,j]位置最小的路径只考虑最小值和次小值即可 看对应代码 class Solution { public: int minFallingPathSum(vector&lt;vector&lt;int>>&amp; grid) { int n = grid.size(); if(n == 1) return grid[0][0]; vector&lt;vector&lt;int>> dp(n, vector&lt;int>(n)); // (i,j)位置在原问题的解 int pos1 = -1, pos2 = -1; //上一行最小及次小值所在的列 for(int i = 0; i &lt; n; i++){ dp[0][i] = grid[0][i]; if(dp[0][i] &lt;= (pos1 == -1 ? INT_MAX : dp[0][pos1])){ //当前值小于等于最小值时,同时更新pos1和pos2 pos2 = pos1; //此处应该先更新pos2,然后更新pos1 pos1 = i; } else if(dp[0][i] &lt; (pos2 == -1 ? INT_MAX : dp[0][pos2])){ //当前值大于最小值,小于次小值时,更新pos2 pos2 = i; } } for(int i = 1; i &lt; n; i++){ for(int j = 0; j &lt; n; j++){ dp[i][j] = (j != pos1 ? dp[i-1][pos1] : dp[i-1][pos2]) + grid[i][j]; } pos1 = -1, pos2 = -1; //需重置 计算当前行数字和最小及次小所在的列 for(int j = 0; j &lt; n; j++){ if(dp[i][j] &lt;= (pos1 == -1 ? INT_MAX : dp[i][pos1])){ pos2 = pos1; pos1 = j; } else if(dp[i][j] &lt; (pos2 == -1 ? INT_MAX : dp[i][pos2])){ pos2 = j; } } } return dp[n-1][pos1]; } }; //感谢热心作者：秦时明月 //链接：https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/r8obm3/?discussion=rQGrX1","categories":[{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/C/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/LeetCode/"},{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/C/"},{"name":"DP","slug":"DP","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/DP/"}]},{"title":"微信文件过期solution","slug":"微信文件过期solution","date":"2022-09-09T16:09:18.000Z","updated":"2022-09-14T12:39:32.320Z","comments":true,"path":"2022/09/10/微信文件过期solution/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/10/%E5%BE%AE%E4%BF%A1%E6%96%87%E4%BB%B6%E8%BF%87%E6%9C%9Fsolution/","excerpt":"微信文件过期了怎么办？急急急急急。。","text":"cr.豆瓣句号小组 【ps】由于句号组的帖子很容易殉o(╥﹏╥)o，所以都截图保存了感谢原作者桃子老师的分享~","categories":[{"name":"生活","slug":"生活","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"豆瓣","slug":"豆瓣","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E8%B1%86%E7%93%A3/"},{"name":"实用技巧","slug":"实用技巧","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"生活","slug":"生活","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E7%94%9F%E6%B4%BB/"}]},{"title":"DP Day2","slug":"DP-Day2","date":"2022-09-06T14:02:27.000Z","updated":"2022-09-15T11:43:21.396Z","comments":true,"path":"2022/09/06/DP-Day2/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/06/DP-Day2/","excerpt":"DP“最小路径和”问题","text":"第一题给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。链接：https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/rtcz3i/ 思路大致和DP1的思想一致：1、先定义状态f[m][n]2、找出状态转移函数ps.最重要的就是搞清楚状态定义！！f[m][n]意味着什么？f[m-1][n]又意味着什么？它们之间的关系为什么是这样？搞清楚状态定义基本上解决了这种题目。比较简单，直接看代码吧 class Solution { public: int minPathSum(vector&lt;vector&lt;int>>&amp; grid) { int m=grid.size(); int n=grid[0].size(); int f[m][n];//到(m+1,n+1)点的总长度 f[0][0]=grid[0][0]; for(int i=0;i&lt;m;i++) { for(int j=0;j&lt;n;j++) { if(i>0&amp;&amp;j>0) { if(f[i][j-1]>=f[i-1][j]) f[i][j]=f[i-1][j]+grid[i][j]; else f[i][j]=f[i][j-1]+grid[i][j]; } else if(i>0) f[i][j]=f[i-1][j]+grid[i][j]; else if(j>0) f[i][j]=f[i][j-1]+grid[i][j]; } } return f[m-1][n-1]; } }; 原作者宫水三叶的解析作者希望通过「最小路径和」问题来分享如何进行「维度合并」来降低“出错风险”和“Debug 难度”。这是 DP 问题中的一个常用技巧：通过「问题等价变换」来降低编码难度。这道题也不难，为什么需要等价变换呢？作者在进阶版中，输出了总和最低的路径，输出路径可以便于程序员以及参考代码者查看相关路径，便于debug而原做法是顺序推导的,那么在寻找最短路径的过程中，到不同节点的最短路径index也是顺序存储的但是由于最短路径可能多于1条，所以我们不能直接在存储路径index的数组顺序读取需要输出的路径那么我们只能倒序读取，而倒序读取必然需要新的数组存储数值，因为我们要正序输出新的数组就会消耗更多空间因此，我们可以「问题等价变换」 作者的解决办法：1、倒推从终点倒推到起点2、信息存储使用「一维数组」存储「二维信息」，这是一个常见的手段。一维数组：idx的函数，我们可以通过函数得出idx的行和列二维信息：路径点的行和列 由于之后还有类似的题目所以自己没有写输出路径的代码，以下是热心同学sheepice写的cpp代码： #include&lt;bits/stdc++.h> using namespace std; int m, n; //m代表行，n代表列 int row(int idx) { //取得所在行 return idx / n; } int col(int idx) { //取得所在列 return idx % n; } int getidx(int x, int y) { //得到每一个一维坐标 return x * n + y; } int main() { cin >> m >> n; vector&lt; vector&lt;int> > grid(m, vector&lt;int>(n,0)); vector&lt; vector&lt;int> > dp(m, vector&lt;int>(n,0)); vector&lt;int> vis(m * n, 0); for(int i =0; i &lt; m; i ++) { //进行数组的输入； for(int j = 0; j &lt; n; j++) { cin >> grid[i][j]; } } //因为要进行路径的输出，因此我们的dp路径从后往前 /* //先进行初始化,但是这样的初始化是不适合找路径的，因为 并没有在这个初始化的过程中记录下来我们的最短路径 dp[m - 1][n - 1] = grid[m - 1][n - 1]; for(int i = m - 2; i >= 0; i--) { dp[i][n - 1] = dp[i + 1][n - 1] + grid[i][n - 1]; } for(int i = n - 2; i>=0; i--) { dp[m - 1][i] = dp[m - 1][i + 1] + grid[m - 1][i]; } */ //开始进行从后往前的递推，并且推的过程记录下来我们的最短路径 for(int i = m - 1; i >= 0; i--) { for(int j = n - 1; j >= 0; j--) { if(i == m - 1 &amp;&amp; j == n - 1) { dp[m - 1][n - 1] = grid[m - 1][n - 1]; } else { int bot = i + 1 &lt; m ? grid[i][j] + dp[i + 1][j] : INT_MAX; int rht = j + 1 &lt; n ? grid[i][j] + dp[i][j + 1] : INT_MAX; dp[i][j] = min(bot, rht); vis[getidx(i, j)] = bot &lt; rht ? getidx(i + 1,j) : getidx(i, j + 1); } } } int idx = getidx(0, 0); cout &lt;&lt; \"最短的路径为：\" &lt;&lt; endl; for(int i = 1; i &lt; m + n - 1; i++) { cout &lt;&lt; \"(\" &lt;&lt; row(idx) &lt;&lt; \",\" &lt;&lt; col(idx) &lt;&lt; \")->\"; idx = vis[idx]; } cout &lt;&lt; \"(\" &lt;&lt; row(idx) &lt;&lt; \",\" &lt;&lt; col(idx) &lt;&lt; \")\" &lt;&lt; endl; cout &lt;&lt;\"最短的路径和为:\" &lt;&lt; endl; cout &lt;&lt; dp[0][0] &lt;&lt; endl; } //作者：sheepice //链接：https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/rtb68e/?discussion=d2e6U2 //来源：力扣（LeetCode） 第二题给定一个三角形 triangle ，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1作者：宫水三叶，相关链接 初始思路1、使用dp[i][j]存储到[i][j]点的路径和最终要求：i=m-1,j没有要求在运动过程中j始终&lt;=i2、使用二维数组f进行路径记录，f[index[dp]][line]index[dp]表示哪一条路，line表示哪一层不过由于路径多，如何唯一表示index？能不能按累加定义index？。。。然后就卡住了😅。。 没办法了，仔细看了上一题的解析终于知道为什么从后往前推更方便。。。因为只存储最短路径（1条）的idx所以从后往前推，不然得先存在一个数组里再输出（浪费空间）。。不过三角形怎么从idx推出在哪一行哪一列、、、要不开一个一维数组存储三角形的值算了、、、tri完蛋，还是不会记录，不过三角形倒推就没有正推的问题因为从下往上是唯一的，从上往下是不唯一的然后写出来了下面的东西 class Solution { public: int minimumTotal(vector&lt;vector&lt;int>>&amp; triangle) { int idx=0;//一维三角形数组的idx int line=triangle.size(); int tri[(line+1)*line/2]; for(int row=0;row&lt;line;row++) { for(int col=0;col&lt;=row;col++) { tri[idx]=triangle[row][col]; idx++; } }//以上的最后没用上，是原来想输出路径（failed）写的 int dp[line][line]; memset(dp,0,sizeof(dp)); for(int i=line-1;i>=0;i--) { for(int j=i;j>=0;j--) { if(i==line-1) dp[i][j]=triangle[i][j]; else { int up,ulft; //up=(j!=i)?dp[i+1][j]+triangle[i][j]:INT_MAX; //ulft=(j!=0)?dp[i+1][j+1]+triangle[i][j]:INT_MAX; up=dp[i+1][j]+triangle[i][j]; ulft=dp[i+1][j+1]+triangle[i][j]; dp[i][j]=min(up,ulft); } } } return dp[0][0]; } }; 最后看评论，如何节约空间的方法：因为对状态是如何转移不感兴趣，程序员在调试的时候感兴趣（debug）由于用户不感兴趣，因此可以直接在原三角形上更改（？有点危险 作者解析本题是否可以使用DP解决，要分析有无后效性首先，既然是从上到下的路径，那么最后一个点必然是落在最后一行。对于最后一行的某个位置的值，根据题意只能从上一行的某一个位置或者某两个位置之一转移而来。同时，我们只关注前一位的累加值是多少，而不关心这个累加值结果是由什么路径而来的。这显然就满足了「无后效性」的定义：我们转移某个状态需要用到某个值，但是并不关心该值是如何而来的。更加的学术表达是：当前某个状态确定后，之后的状态转移与之前的决策无关 既然可以使用DP解决该问题，那么我们就需要定义「DP状态」： f[i][j]代表到达某个点的最小路径和状态转移：1、每一行 i 具有 i+1 个数字2、只要不是第一列（j!=0）位置上的数，都能通过「左上方」转移过来3、只要不是每行最后一列（j!=i）位置上的数，都能通过「上方」转移而来 class Solution { public int minimumTotal(List&lt;List&lt;Integer>> tri) { int n = tri.size(); int ans = Integer.MAX_VALUE; int[][] f = new int[n][n]; f[0][0] = tri.get(0).get(0); for (int i = 1; i &lt; n; i++) { for (int j = 0; j &lt; i + 1; j++) { int val = tri.get(i).get(j); f[i][j] = Integer.MAX_VALUE; if (j != 0) f[i][j] = Math.min(f[i][j], f[i - 1][j - 1] + val); if (j != i) f[i][j] = Math.min(f[i][j], f[i - 1][j] + val); } } for (int i = 0; i &lt; n; i++) ans = Math.min(ans, f[n - 1][i]); return ans; } } 进阶递推过程可以发现，在求第 i 行的状态时只依赖于第 i-1 行的状态。那么我们不需要存储所有行的状态值（动规值），可以对空间进行优化。 DP 空间优化技巧 1、滚动数组 2、根据状态依赖调整迭代/循环的方向 **滚动数组**没有任何的思维难度，只需要将其中一维直接改成 2， 将维的 f[i] 改成 f[i&amp;1] 或者 f[i%2] 即可（推荐前者，在不同架构的机器上，运算效率更加稳定）。 这样数组仅存储两行的内容，用完的数据就被覆盖掉 ```java class Solution { public int minimumTotal(List","categories":[{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/C/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/LeetCode/"},{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/C/"},{"name":"DP","slug":"DP","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/DP/"}]},{"title":"DP Day1","slug":"DP-Day1","date":"2022-09-06T14:02:04.000Z","updated":"2022-09-14T12:13:23.573Z","comments":true,"path":"2022/09/06/DP-Day1/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/06/DP-Day1/","excerpt":"DP最基础的“不同路径”问题","text":"第一题一个机器人位于一个 m x n&nbsp;网格的左上角 （起始点在下图中标记为 “Start” ）机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？链接：https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/rtwu06/ 初步的思路：3*7的地图，只能向右或者向下，总共走8步可以到终点，那么就要考虑右和下这两个动作在向量里的位置。如下图所示，需要向右6步，向下2步，那么就计算2个下元素在向量中的位置（无序）。 第一个“下”的位置 第二个“下”的可能 0 7 1 6 2 5 。。 。。 6 1 最后求和，得7*8/2=28不过这种思路很难找到通用的公式（哭） 直接看解析！有人使用递归来解决，递归的关键是1.找到函数关系（把范围变小）2.找到递归结束条件对于这道题来说，范围变小：每移动一步，地图就变小了 本讲重要知识点动态规划（DP）是什么？若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。以下是作者宫水三叶对原题的分析定义 f[i][j]f[i][j] 为到达位置 (i,j)(i,j) 的不同路径数量。那么 f[m-1][n-1]f[m−1][n−1] 就是我们最终的答案，而 f[0][0] = 1是一个显而易见的起始条件。由于题目限定了我们只能往下或者往右移动，因此我们按照当前可选方向进行分析：当前位置只能「往下」移动，即有 f[i][j] = f[i-1][j]当前位置只能「往右」移动，即有 f[i][j] = f[i][j-1]当前位置即能「往下」也能「往右」移动，即有 f[i][j] = f[i][j-1] + f[i-1][j] 因为是好久没接触DP类型的题目，基本忘光，这里直接搬上作者对于这道题的总结 我们是如何确定本题可以使用动态规划来解决的？通常我们要从「有无后效性」进行入手分析。如果对于某个状态，我们可以只关注状态的值，而不需要关注状态是如何转移过来的话，那么这就是一个无后效性的问题，可以考虑使用 DP 解决。另外一个更加实在的技巧，我们还可以通过数据范围来猜测是不是可以用 DP来做。因为DP是一个递推的过程，因此如果数据范围是 10^5~10^6 的话，可以考虑是不是可以使用一维 DP来解决；如果数据范围是 10^2~10^3 的话，可以考虑是不是可以使用二维 DP 来做 … 我们是如何确定本题的状态定义的？说实话，DP 的状态定义很大程度是靠经验去猜的。虽然大多数情况都是猜的，但也不是毫无规律，相当一部分题目的状态定义是与「结尾」或「答案」有所关联 我们是如何确定状态转移方程的？通常来说，如果我们的状态定义猜对了，状态转移方程就是对「最后一步的分情况讨论」。如果我们有一个对的状态定义的话，基本上状态转移方程就是呼之欲出。因此一定程度上，状态转移方程可以反过来验证我们状态定义猜得是否正确：如果猜了一个状态定义，然后发现无法列出涵盖所有情况（不漏）的状态转移方程，多半就是状态定义猜错了，赶紧换个思路，而不是去死磕状态转移方程。 对状态转移的要求是什么？我们的状态转移是要做到「不漏」还是「不重不漏」取决于问题本身：如果是求最值的话，我们只需要确保「不漏」即可，因为重复不影响结果。如果是求方案数的话，我们需要确保「不重不漏」。 我们是如何分析动态规划的时间复杂度的？对于动态规划的复杂度/计算量分析，有多少个状态，复杂度/计算量就是多少。因此一维DP的复杂度通常是线性的 O(n) ，而二维DP的复杂度通常是平方的 O(n^2)。 第二题一个机器人位于一个&nbsp;m x n&nbsp;网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。 第二题是对第一题的巩固，就自己按第一题的思路做了一下。以下是自己写的代码，注释是当时的思路和错误的地方： class Solution { public: int uniquePathsWithObstacles(vector&lt;vector&lt;int>>&amp; obstacleGrid) { int i; int m = obstacleGrid.size(); int n = obstacleGrid[i].size(); int f[m][n]; //memset(f,-1,sizeof(f));//加不加对编译没有影响，但不初始化很危险 f[0][0]=(obstacleGrid[0][0]==0)?1:0;//漏初始条件 for(int i=0;i&lt;m;i++) { for(int j=0;j&lt;n;j++) { if(obstacleGrid[i][j]==1) f[i][j]=0; if(obstacleGrid[i][j]==0) { if(i>0&amp;&amp;j>0) f[i][j]=f[i-1][j]+f[i][j-1]; else if(i>0) f[i][j]=f[i-1][j];//右，注意条件，j=0表示只能向右 else if(j>0) f[i][j]=f[i][j-1];//下 } } } return f[m-1][n-1]; } }; //f[i][j]: //1,o[i-1][j]=1--f[i][j]=f[i][j-1] //2,o[i][j-1]=1--f[i][j]=f[i-1][j] //3,o[i-1][j-1]=0--f[i][j]=f[i][j-1]+f[i-1][j] //4,o[i-1][j-1]=1--f[i][j]=0 //一开始的构思，漏洞百出。。。 //注意vector的格式，二维数组初始化 //一定要清晰定义f[m][n] //当前的状态去推导下一时刻状态，因此不管怎么样等式右边都是x-m（表示过去）的形式，等式左边就是x（当前）","categories":[{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/C/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/LeetCode/"},{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/C/"},{"name":"DP","slug":"DP","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/DP/"}]},{"title":"累了就休息一下，看一点人间喜剧","slug":"累了就休息一下，看一点人间喜剧","date":"2022-09-04T09:01:52.000Z","updated":"2022-09-15T12:09:39.572Z","comments":true,"path":"2022/09/04/累了就休息一下，看一点人间喜剧/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/04/%E7%B4%AF%E4%BA%86%E5%B0%B1%E4%BC%91%E6%81%AF%E4%B8%80%E4%B8%8B%EF%BC%8C%E7%9C%8B%E4%B8%80%E7%82%B9%E4%BA%BA%E9%97%B4%E5%96%9C%E5%89%A7/","excerpt":"很有意思的社死相关帖子","text":"叔叔你别拉了，我害怕推荐理由：作者语言描述能力惊人，画面感十足 封校期间在QQ上被QQ自动回复社死推荐理由：很有意思的自动回复格式，激发没有幽默感的我的灵感 没想到被一个❤尬住了推荐理由：。。。。sorry因为这颗❤我笑出了眼泪 失手把狗狗照片发进工作群，而工作群正在。。。推荐理由：what a coincidence 为了吵架更有气势改名字，结果打错了字推荐理由：豆瓣的提示，蛮有意思的，正经中带着一丝丝粗鲁 朋友误以为我买了gang塞推荐理由：本来以为不喜欢这种段子，没想到被lz的朋友温暖到了😭","categories":[{"name":"乐一乐","slug":"乐一乐","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/%E4%B9%90%E4%B8%80%E4%B9%90/"}],"tags":[{"name":"社死","slug":"社死","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E7%A4%BE%E6%AD%BB/"},{"name":"豆瓣","slug":"豆瓣","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E8%B1%86%E7%93%A3/"}]}],"categories":[{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/C/"},{"name":"生活","slug":"生活","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/%E7%94%9F%E6%B4%BB/"},{"name":"乐一乐","slug":"乐一乐","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/%E4%B9%90%E4%B8%80%E4%B9%90/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/LeetCode/"},{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/C/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/DFS/"},{"name":"DP","slug":"DP","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/DP/"},{"name":"豆瓣","slug":"豆瓣","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E8%B1%86%E7%93%A3/"},{"name":"实用技巧","slug":"实用技巧","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"},{"name":"生活","slug":"生活","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E7%94%9F%E6%B4%BB/"},{"name":"社死","slug":"社死","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E7%A4%BE%E6%AD%BB/"}]}