{"meta":{"title":"Eloise Wang","subtitle":"个人主页","description":"","author":"Eloise_W","url":"https://Harper00vv00/Harper00vv00.github.io","root":"/"},"pages":[{"title":"about","date":"2022-09-04T15:13:32.000Z","updated":"2022-09-04T15:20:18.960Z","comments":true,"path":"about/index.html","permalink":"https://harper00vv00/Harper00vv00.github.io/about/index.html","excerpt":"","text":"profile: avater: #头像 career: 打工人 introduction： 一技之长，衣食无忧 my Projects: enable: false my Skills: enable: true data: cpp: background: ‘linear-gradient(to right, #9900FF 0%, #CC66FF 100%)’ percent: 80% my Gallery: #相册 enable: false"},{"title":"categories","date":"2022-09-04T15:27:32.000Z","updated":"2022-09-04T15:28:29.097Z","comments":true,"path":"categories/index.html","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2022-09-04T15:26:34.000Z","updated":"2022-09-04T15:28:51.838Z","comments":true,"path":"contact/index.html","permalink":"https://harper00vv00/Harper00vv00.github.io/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-09-04T15:20:33.000Z","updated":"2022-09-04T15:21:33.872Z","comments":true,"path":"tags/index.html","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2022-09-04T15:26:50.000Z","updated":"2022-09-04T15:29:12.928Z","comments":true,"path":"friends/index.html","permalink":"https://harper00vv00/Harper00vv00.github.io/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"DP Day2","slug":"DP-Day2","date":"2022-09-06T14:02:27.000Z","updated":"2022-09-09T15:28:48.643Z","comments":true,"path":"2022/09/06/DP-Day2/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/06/DP-Day2/","excerpt":"DP“最小路径和”问题","text":"第一题给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。链接：https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/rtcz3i/ 思路大致和DP1的思想一致：1、先定义状态f[m][n]2、找出状态转移函数ps.最重要的就是搞清楚状态定义！！f[m][n]意味着什么？f[m-1][n]又意味着什么？它们之间的关系为什么是这样？搞清楚状态定义基本上解决了这种题目。比较简单，直接看代码吧 class Solution { public: int minPathSum(vector&lt;vector&lt;int>>&amp; grid) { int m=grid.size(); int n=grid[0].size(); int f[m][n];//到(m+1,n+1)点的总长度 f[0][0]=grid[0][0]; for(int i=0;i&lt;m;i++) { for(int j=0;j&lt;n;j++) { if(i>0&amp;&amp;j>0) { if(f[i][j-1]>=f[i-1][j]) f[i][j]=f[i-1][j]+grid[i][j]; else f[i][j]=f[i][j-1]+grid[i][j]; } else if(i>0) f[i][j]=f[i-1][j]+grid[i][j]; else if(j>0) f[i][j]=f[i][j-1]+grid[i][j]; } } return f[m-1][n-1]; } }; 原作者宫水三叶的解析作者希望通过「最小路径和」问题来分享如何进行「维度合并」来降低“出错风险”和“Debug 难度”。这是 DP 问题中的一个常用技巧：通过「问题等价变换」来降低编码难度。这道题也不难，为什么需要等价变换呢？作者在进阶版中，输出了总和最低的路径，输出路径可以便于程序员以及参考代码者查看相关路径，便于debug而原做法是顺序推导的,那么在寻找最短路径的过程中，到不同节点的最短路径index也是顺序存储的但是由于最短路径可能多于1条，所以我们不能直接在存储路径index的数组顺序读取需要输出的路径那么我们只能倒序读取，而倒序读取必然需要新的数组存储数值，因为我们要正序输出新的数组就会消耗更多空间因此，我们可以「问题等价变换」 作者的解决办法：1、倒推从终点倒推到起点2、信息存储使用「一维数组」存储「二维信息」，这是一个常见的手段。一维数组：idx的函数，我们可以通过函数得出idx的行和列二维信息：路径点的行和列 由于之后还有类似的题目所以自己没有写输出路径的代码，以下是热心同学sheepice写的cpp代码： #include&lt;bits/stdc++.h> using namespace std; int m, n; //m代表行，n代表列 int row(int idx) { //取得所在行 return idx / n; } int col(int idx) { //取得所在列 return idx % n; } int getidx(int x, int y) { //得到每一个一维坐标 return x * n + y; } int main() { cin >> m >> n; vector&lt; vector&lt;int> > grid(m, vector&lt;int>(n,0)); vector&lt; vector&lt;int> > dp(m, vector&lt;int>(n,0)); vector&lt;int> vis(m * n, 0); for(int i =0; i &lt; m; i ++) { //进行数组的输入； for(int j = 0; j &lt; n; j++) { cin >> grid[i][j]; } } //因为要进行路径的输出，因此我们的dp路径从后往前 /* //先进行初始化,但是这样的初始化是不适合找路径的，因为 并没有在这个初始化的过程中记录下来我们的最短路径 dp[m - 1][n - 1] = grid[m - 1][n - 1]; for(int i = m - 2; i >= 0; i--) { dp[i][n - 1] = dp[i + 1][n - 1] + grid[i][n - 1]; } for(int i = n - 2; i>=0; i--) { dp[m - 1][i] = dp[m - 1][i + 1] + grid[m - 1][i]; } */ //开始进行从后往前的递推，并且推的过程记录下来我们的最短路径 for(int i = m - 1; i >= 0; i--) { for(int j = n - 1; j >= 0; j--) { if(i == m - 1 &amp;&amp; j == n - 1) { dp[m - 1][n - 1] = grid[m - 1][n - 1]; } else { int bot = i + 1 &lt; m ? grid[i][j] + dp[i + 1][j] : INT_MAX; int rht = j + 1 &lt; n ? grid[i][j] + dp[i][j + 1] : INT_MAX; dp[i][j] = min(bot, rht); vis[getidx(i, j)] = bot &lt; rht ? getidx(i + 1,j) : getidx(i, j + 1); } } } int idx = getidx(0, 0); cout &lt;&lt; \"最短的路径为：\" &lt;&lt; endl; for(int i = 1; i &lt; m + n - 1; i++) { cout &lt;&lt; \"(\" &lt;&lt; row(idx) &lt;&lt; \",\" &lt;&lt; col(idx) &lt;&lt; \")->\"; idx = vis[idx]; } cout &lt;&lt; \"(\" &lt;&lt; row(idx) &lt;&lt; \",\" &lt;&lt; col(idx) &lt;&lt; \")\" &lt;&lt; endl; cout &lt;&lt;\"最短的路径和为:\" &lt;&lt; endl; cout &lt;&lt; dp[0][0] &lt;&lt; endl; } //作者：sheepice //链接：https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/rtb68e/?discussion=d2e6U2 //来源：力扣（LeetCode） 第二题给定一个三角形 triangle ，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1","categories":[{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/C/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/LeetCode/"},{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/C/"},{"name":"DP","slug":"DP","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/DP/"}]},{"title":"DP Day1","slug":"DP-Day1","date":"2022-09-06T14:02:04.000Z","updated":"2022-09-08T13:45:58.859Z","comments":true,"path":"2022/09/06/DP-Day1/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/06/DP-Day1/","excerpt":"DP最基础的“不同路径”问题","text":"第一题一个机器人位于一个 m x n&nbsp;网格的左上角 （起始点在下图中标记为 “Start” ）机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？链接：https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/rtwu06/ 初步的思路：3*7的地图，只能向右或者向下，总共走8步可以到终点，那么就要考虑右和下这两个动作在向量里的位置。如下图所示，需要向右6步，向下2步，那么就计算2个下元素在向量中的位置（无序）。 第一个“下”的位置 第二个“下”的可能 0 7 1 6 2 5 。。 。。 6 1 最后求和，得7*8/2=28不过这种思路很难找到通用的公式（哭） 直接看解析！有人使用递归来解决，递归的关键是1.找到函数关系（把范围变小）2.找到递归结束条件对于这道题来说，范围变小：每移动一步，地图就变小了 本讲重要知识点动态规划（DP）是什么？若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。以下是作者宫水三叶对原题的分析定义 f[i][j]f[i][j] 为到达位置 (i,j)(i,j) 的不同路径数量。那么 f[m-1][n-1]f[m−1][n−1] 就是我们最终的答案，而 f[0][0] = 1是一个显而易见的起始条件。由于题目限定了我们只能往下或者往右移动，因此我们按照当前可选方向进行分析：当前位置只能「往下」移动，即有 f[i][j] = f[i-1][j]当前位置只能「往右」移动，即有 f[i][j] = f[i][j-1]当前位置即能「往下」也能「往右」移动，即有 f[i][j] = f[i][j-1] + f[i-1][j] 因为是好久没接触DP类型的题目，基本忘光，这里直接搬上作者对于这道题的总结 我们是如何确定本题可以使用动态规划来解决的？通常我们要从「有无后效性」进行入手分析。如果对于某个状态，我们可以只关注状态的值，而不需要关注状态是如何转移过来的话，那么这就是一个无后效性的问题，可以考虑使用 DP 解决。另外一个更加实在的技巧，我们还可以通过数据范围来猜测是不是可以用 DP来做。因为DP是一个递推的过程，因此如果数据范围是 10^5~10^6 的话，可以考虑是不是可以使用一维 DP来解决；如果数据范围是 10^2~10^3 的话，可以考虑是不是可以使用二维 DP 来做 … 我们是如何确定本题的状态定义的？说实话，DP 的状态定义很大程度是靠经验去猜的。虽然大多数情况都是猜的，但也不是毫无规律，相当一部分题目的状态定义是与「结尾」或「答案」有所关联 我们是如何确定状态转移方程的？通常来说，如果我们的状态定义猜对了，状态转移方程就是对「最后一步的分情况讨论」。如果我们有一个对的状态定义的话，基本上状态转移方程就是呼之欲出。因此一定程度上，状态转移方程可以反过来验证我们状态定义猜得是否正确：如果猜了一个状态定义，然后发现无法列出涵盖所有情况（不漏）的状态转移方程，多半就是状态定义猜错了，赶紧换个思路，而不是去死磕状态转移方程。 对状态转移的要求是什么？我们的状态转移是要做到「不漏」还是「不重不漏」取决于问题本身：如果是求最值的话，我们只需要确保「不漏」即可，因为重复不影响结果。如果是求方案数的话，我们需要确保「不重不漏」。 我们是如何分析动态规划的时间复杂度的？对于动态规划的复杂度/计算量分析，有多少个状态，复杂度/计算量就是多少。因此一维DP的复杂度通常是线性的 O(n) ，而二维DP的复杂度通常是平方的 O(n^2)。 第二题一个机器人位于一个&nbsp;m x n&nbsp;网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？网格中的障碍物和空位置分别用 1 和 0 来表示。 第二题是对第一题的巩固，就自己按第一题的思路做了一下。以下是自己写的代码，注释是当时的思路和错误的地方： class Solution { public: int uniquePathsWithObstacles(vector&lt;vector&lt;int>>&amp; obstacleGrid) { int i; int m = obstacleGrid.size(); int n = obstacleGrid[i].size(); int f[m][n]; //memset(f,-1,sizeof(f));//加不加对编译没有影响，但不初始化很危险 f[0][0]=(obstacleGrid[0][0]==0)?1:0;//漏初始条件 for(int i=0;i&lt;m;i++) { for(int j=0;j&lt;n;j++) { if(obstacleGrid[i][j]==1) f[i][j]=0; if(obstacleGrid[i][j]==0) { if(i>0&amp;&amp;j>0) f[i][j]=f[i-1][j]+f[i][j-1]; else if(i>0) f[i][j]=f[i-1][j];//右，注意条件，j=0表示只能向右 else if(j>0) f[i][j]=f[i][j-1];//下 } } } return f[m-1][n-1]; } }; //f[i][j]: //1,o[i-1][j]=1--f[i][j]=f[i][j-1] //2,o[i][j-1]=1--f[i][j]=f[i-1][j] //3,o[i-1][j-1]=0--f[i][j]=f[i][j-1]+f[i-1][j] //4,o[i-1][j-1]=1--f[i][j]=0 //一开始的构思，漏洞百出。。。 //注意vector的格式，二维数组初始化 //一定要清晰定义f[m][n] //当前的状态去推导下一时刻状态，因此不管怎么样等式右边都是x-m（表示过去）的形式，等式左边就是x（当前）","categories":[{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/C/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/LeetCode/"},{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/C/"},{"name":"DP","slug":"DP","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/DP/"}]},{"title":"累了就休息一下，看一点人间喜剧","slug":"累了就休息一下，看一点人间喜剧","date":"2022-09-04T09:01:52.000Z","updated":"2022-09-09T15:59:11.538Z","comments":true,"path":"2022/09/04/累了就休息一下，看一点人间喜剧/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/04/%E7%B4%AF%E4%BA%86%E5%B0%B1%E4%BC%91%E6%81%AF%E4%B8%80%E4%B8%8B%EF%BC%8C%E7%9C%8B%E4%B8%80%E7%82%B9%E4%BA%BA%E9%97%B4%E5%96%9C%E5%89%A7/","excerpt":"很有意思的社死相关帖子","text":"叔叔你别拉了，我害怕https://www.douban.com/group/topic/220795011/?_i=622889837471b5d&amp;dt_dapp=1推荐理由：作者语言描述能力惊人，画面感十足 封校期间在QQ上被QQ自动回复社死https://www.douban.com/group/topic/263019480/?_i=627354628775935&amp;dt_dapp=1推荐理由：很有意思的自动回复格式，激发没有幽默感的我的灵感 没想到被一个❤尬住了https://www.douban.com/group/topic/266612983/?_i=62735200bbb8f76&amp;dt_dapp=1推荐理由：。。。。sorry因为这颗❤我笑出了眼泪 失手把狗狗照片发进工作群，而工作群正在。。。https://www.douban.com/group/topic/269915014/?_i=62737868e16e5d9&amp;dt_dapp=1推荐理由：what a coincidence","categories":[{"name":"乐一乐","slug":"乐一乐","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/%E4%B9%90%E4%B8%80%E4%B9%90/"}],"tags":[{"name":"社死","slug":"社死","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E7%A4%BE%E6%AD%BB/"},{"name":"豆瓣","slug":"豆瓣","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E8%B1%86%E7%93%A3/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-09-02T08:43:11.024Z","updated":"2022-09-02T08:43:11.024Z","comments":true,"path":"2022/09/02/hello-world/","link":"","permalink":"https://harper00vv00/Harper00vv00.github.io/2022/09/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/C/"},{"name":"乐一乐","slug":"乐一乐","permalink":"https://harper00vv00/Harper00vv00.github.io/categories/%E4%B9%90%E4%B8%80%E4%B9%90/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/LeetCode/"},{"name":"C++","slug":"C","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/C/"},{"name":"DP","slug":"DP","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/DP/"},{"name":"社死","slug":"社死","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E7%A4%BE%E6%AD%BB/"},{"name":"豆瓣","slug":"豆瓣","permalink":"https://harper00vv00/Harper00vv00.github.io/tags/%E8%B1%86%E7%93%A3/"}]}