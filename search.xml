<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DP Day2</title>
      <link href="/2022/09/06/DP-Day2/"/>
      <url>/2022/09/06/DP-Day2/</url>
      
        <content type="html"><![CDATA[<p>累累累累</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -LeetCode -C++ -DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP Day1</title>
      <link href="/2022/09/06/DP-Day1/"/>
      <url>/2022/09/06/DP-Day1/</url>
      
        <content type="html"><![CDATA[<p><font face="STCAIYUN" size="7" color="#A52A2A">第一题</font><br>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>问总共有多少条不同的路径？<br><img src="/images/DP1.png" alt="question"><br>链接：<a href="https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/rtwu06/">https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/rtwu06/</a>  </p><p>初步的思路：3*7的地图，只能向右或者向下，总共走8步可以到终点，那么就要考虑右和下这两个动作在向量里的位置。<br>如下图所示，需要向右6步，向下2步，那么就计算2个下元素在向量中的位置（无序）。  </p><table><thead><tr><th>第一个“下”的位置</th><th>第二个“下”的可能</th></tr></thead><tbody><tr><td>0</td><td>7</td></tr><tr><td>1</td><td>6</td></tr><tr><td>2</td><td>5</td></tr><tr><td>。。</td><td>。。</td></tr><tr><td>6</td><td>1</td></tr></tbody></table><p>最后求和，得7*8&#x2F;2&#x3D;28<br><em><strong>不过这种思路很难找到通用的公式（哭）</strong></em>  </p><hr><p><strong>直接看解析！</strong><br>有人使用<strong>递归</strong>来解决，递归的关键是1.找到函数关系（把范围变小）2.找到递归结束条件<br>对于这道题来说，范围变小：每移动一步，地图就变小了  </p><p><em>本讲重要知识点</em><br><font face="STCAIYUN" size="6" color="#006400">动态规划（DP）</font><br><strong>是什么？</strong>若要解一个给定问题，我们需要解其不同部分（即<strong>子问题</strong>），再<strong>合并子问题的解</strong>以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其<strong>记忆化存储</strong>，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。<br><strong>以下是作者宫水三叶对原题的分析</strong><br>定义 f[i][j]f[i][j] 为到达位置 (i,j)(i,j) 的不同路径数量。<br>那么 f[m-1][n-1]f[m−1][n−1] 就是我们最终的答案，而 f[0][0] &#x3D; 1是一个显而易见的起始条件。<br>由于题目限定了我们只能<em>往下</em>或者<em>往右</em>移动，因此我们按照<strong>当前可选方向</strong>进行分析：<br>当前位置只能「往下」移动，即有 f[i][j] &#x3D; f[i-1][j]<br>当前位置只能「往右」移动，即有 f[i][j] &#x3D; f[i][j-1]<br>当前位置即能「往下」也能「往右」移动，即有 f[i][j] &#x3D; f[i][j-1] + f[i-1][j]</p><hr><p><em>因为是好久没接触DP类型的题目，基本忘光，这里直接搬上作者对于这道题的总结</em>  </p><ol><li><p>我们是如何确定本题可以使用动态规划来解决的？<br>通常我们要从「有无后效性」进行入手分析。<br>如果对于某个状态，我们可以只关注状态的值，而不需要关注状态是如何转移过来的话，那么这就是一个无后效性的问题，可以考虑使用 DP 解决。<br>另外一个更加实在的技巧，我们还可以通过<em>数据范围</em>来猜测是不是可以用 DP来做。<br>因为DP是一个递推的过程，因此如果数据范围是 10^5~10^6 的话，可以考虑是不是可以使用一维 DP来解决；<br>如果数据范围是 10^2~10^3 的话，可以考虑是不是可以使用二维 DP 来做 …</p></li><li><p>我们是如何确定本题的状态定义的？<br>说实话，DP 的状态定义很大程度是靠经验去猜的。<br>虽然大多数情况都是猜的，但也不是毫无规律，相当一部分题目的状态定义是与「结尾」或「答案」有所关联</p></li><li><p>我们是如何确定状态转移方程的？<br>通常来说，如果我们的状态定义猜对了，状态转移方程就是对「最后一步的分情况讨论」。<br>如果我们有一个对的状态定义的话，基本上状态转移方程就是呼之欲出。<br>因此一定程度上，状态转移方程可以反过来验证我们状态定义猜得是否正确：<br>如果猜了一个状态定义，然后发现无法列出涵盖所有情况（不漏）的状态转移方程，多半就是状态定义猜错了，赶紧换个思路，而不是去死磕状态转移方程。</p></li><li><p>对状态转移的要求是什么？<br>我们的状态转移是要做到「不漏」还是「不重不漏」取决于问题本身：<br>如果是求最值的话，我们只需要确保「不漏」即可，因为重复不影响结果。<br>如果是求方案数的话，我们需要确保「不重不漏」。</p></li><li><p>我们是如何分析动态规划的时间复杂度的？<br>对于动态规划的复杂度&#x2F;计算量分析，有多少个状态，复杂度&#x2F;计算量就是多少。<br>因此一维DP的复杂度通常是线性的 O(n) ，而二维DP的复杂度通常是平方的 O(n^2)。</p></li></ol><hr><p><font face="STCAIYUN" size="6" color="#A52A2A">第二题</font><br>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。<br>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br>网格中的障碍物和空位置分别用 1 和 0 来表示。<br><img src="/images/DP2.jpg" alt="question2">  </p><p>第二题是对第一题的巩固，就自己按第一题的思路做了一下。<br>以下是自己写的代码，注释是当时的思路和错误的地方：</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">class Solution &#123;public:    int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123;        int i;        int m &#x3D; obstacleGrid.size();        int n &#x3D; obstacleGrid[i].size();        int f[m][n];        &#x2F;&#x2F;memset(f,-1,sizeof(f));&#x2F;&#x2F;加不加对编译没有影响，但不初始化很危险        f[0][0]&#x3D;(obstacleGrid[0][0]&#x3D;&#x3D;0)?1:0;&#x2F;&#x2F;漏初始条件        for(int i&#x3D;0;i&lt;m;i++)        &#123;            for(int j&#x3D;0;j&lt;n;j++)            &#123;                if(obstacleGrid[i][j]&#x3D;&#x3D;1) f[i][j]&#x3D;0;                if(obstacleGrid[i][j]&#x3D;&#x3D;0)                 &#123;                    if(i&gt;0&amp;&amp;j&gt;0) f[i][j]&#x3D;f[i-1][j]+f[i][j-1];                    else if(i&gt;0) f[i][j]&#x3D;f[i-1][j];&#x2F;&#x2F;右，注意条件，j&#x3D;0表示只能向右                    else if(j&gt;0) f[i][j]&#x3D;f[i][j-1];&#x2F;&#x2F;下                &#125;            &#125;        &#125;        return f[m-1][n-1];    &#125;&#125;;&#x2F;&#x2F;f[i][j]:&#x2F;&#x2F;1,o[i-1][j]&#x3D;1--f[i][j]&#x3D;f[i][j-1]&#x2F;&#x2F;2,o[i][j-1]&#x3D;1--f[i][j]&#x3D;f[i-1][j]&#x2F;&#x2F;3,o[i-1][j-1]&#x3D;0--f[i][j]&#x3D;f[i][j-1]+f[i-1][j]&#x2F;&#x2F;4,o[i-1][j-1]&#x3D;1--f[i][j]&#x3D;0&#x2F;&#x2F;一开始的构思，漏洞百出。。。&#x2F;&#x2F;注意vector的格式，二维数组初始化&#x2F;&#x2F;一定要清晰定义f[m][n]&#x2F;&#x2F;当前的状态去推导下一时刻状态，因此不管怎么样等式右边都是x-m（表示过去）的形式，等式左边就是x（当前）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -LeetCode -C++ -DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>累了就休息一下，看一点人间喜剧</title>
      <link href="/2022/09/04/%E7%B4%AF%E4%BA%86%E5%B0%B1%E4%BC%91%E6%81%AF%E4%B8%80%E4%B8%8B%EF%BC%8C%E7%9C%8B%E4%B8%80%E7%82%B9%E4%BA%BA%E9%97%B4%E5%96%9C%E5%89%A7/"/>
      <url>/2022/09/04/%E7%B4%AF%E4%BA%86%E5%B0%B1%E4%BC%91%E6%81%AF%E4%B8%80%E4%B8%8B%EF%BC%8C%E7%9C%8B%E4%B8%80%E7%82%B9%E4%BA%BA%E9%97%B4%E5%96%9C%E5%89%A7/</url>
      
        <content type="html"><![CDATA[<p>叔叔你别拉了，我害怕<br><a href="https://www.douban.com/group/topic/220795011/?_i=622889837471b5d&amp;dt_dapp=1">https://www.douban.com/group/topic/220795011/?_i=622889837471b5d&amp;dt_dapp=1</a></p>]]></content>
      
      
      <categories>
          
          <category> 乐一乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -社死 -豆瓣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/09/02/hello-world/"/>
      <url>/2022/09/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new &quot;My New Post&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
