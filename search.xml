<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>栈与队列</title>
      <link href="/2022/09/21/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
      <url>/2022/09/21/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p><font size="6" face="黑体"><strong>栈的基本操作</strong></font></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">//1 标准库与定义</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;stack></span> </span>stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//2 基础操作</span>s<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//如果栈为空则返回true, 否则返回false;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//返回栈中元素的个数</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//返回栈顶元素, 但不删除该元素</span>s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">//弹出栈顶元素, 但不返回其值</span>s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//将元素压入栈顶</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><font size="6" face="黑体"><strong>栈练习题1</strong></font><br><strong>剑指 Offer 09. 用两个栈实现队列</strong><br>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead&nbsp;操作返回 -1 )<br><a href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/5dq0t5/">解题思路</a></p><p><em>自己写的代码以及遇到的问题</em></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">CQueue</span> <span class="token punctuation">{</span><span class="token keyword">private</span><span class="token operator">:</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> A<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//入栈</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> B<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//出栈</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token function">CQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//默认构造函数</span>    <span class="token punctuation">}</span>        <span class="token keyword">void</span> <span class="token function">appendTail</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        A<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">int</span> <span class="token function">deleteHead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>B<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//B非空</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> res<span class="token operator">=</span>B<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            B<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                   <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>A<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">int</span> val<span class="token operator">=</span>A<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                A<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                B<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> result<span class="token operator">=</span>B<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            B<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> result<span class="token punctuation">;</span>                           <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Your CQueue object will be instantiated and called as such: * CQueue* obj = new CQueue(); * obj->appendTail(value); * int param_2 = obj->deleteHead();解题过程中遇到的问题：1. 编译错误：non-void function does not return a value in all control paths [-Werror,-Wreturn-type]修改：如果B非空为第一种可能性，那么第二种可能性就是default，不用写if(B空) */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><font size="6" face="黑体"><strong>栈练习题2</strong></font><br><strong>剑指 Offer 30. 包含 min 函数的栈</strong><br>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。<br><a href="https://leetcode.cn/leetbook/read/illustration-of-algorithm/50je8m/">解题思路</a><br><em>自己写的代码以及遇到的问题</em></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">MinStack</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    stack<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> s<span class="token punctuation">,</span>minstack<span class="token punctuation">;</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token comment" spellcheck="true">/** initialize your data structure here. */</span>    <span class="token function">MinStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>        <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        s<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>minstack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">||</span>x<span class="token operator">&lt;=</span>minstack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> minstack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> top_s<span class="token punctuation">,</span>top_minstack<span class="token punctuation">;</span>        top_s<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        top_minstack<span class="token operator">=</span>minstack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>top_s<span class="token operator">==</span>top_minstack<span class="token punctuation">)</span> minstack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        s<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">int</span> <span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token keyword">int</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> minstack<span class="token punctuation">.</span><span class="token function">top</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj->push(x); * obj->pop(); * int param_3 = obj->top(); * int param_4 = obj->min();1 执行错误：Line 175: Char 16: runtime error: reference binding to misaligned address 0xbebebebebebec0ba for type 'int', which requires 4 byte alignment (stl_deque.h)0xbebebebebebec0ba: note: pointer points here&lt;memory cannot be printed>SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_deque.h:180:16  修改：push函数 if(x&lt;minstack.top())改成if(x&lt;=minstack.top()) 原因：有可能最后两个push的数都是最小值，然而pop函数将最小值pop掉只留次小2 执行结果（答案）错误 修改：push函数 两行if改成if(minstack.empty()||x&lt;=minstack.top()) 或者 if。。else if。。 原因：如果不使用“或”，而拆分成两行if，当minstack为空，会push两次 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>小结</strong><br>1 解题时先分析不同方法的时间复杂度<br>2 解题时一定要注意边界条件是“&gt;”还是“&gt;=”</p><hr><p><strong>其他</strong><br><a href="https://blog.csdn.net/zichen_ziqi/article/details/80807989?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166372168616782417054788%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=166372168616782417054788&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-80807989-null-null.142%5Ev48%5Epc_rank_34_default_3,201%5Ev3%5Econtrol&amp;utm_term=%E6%A0%88%20c++&amp;spm=1018.2226.3001.4187">栈的拓展阅读</a></p>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用电子元器件</title>
      <link href="/2022/09/21/%E5%B8%B8%E7%94%A8%E7%94%B5%E5%AD%90%E5%85%83%E5%99%A8%E4%BB%B6/"/>
      <url>/2022/09/21/%E5%B8%B8%E7%94%A8%E7%94%B5%E5%AD%90%E5%85%83%E5%99%A8%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p><font face="黑体" size="6">电容</font></p><!-- toc --><!-- tocstop --><ol><li>降压<br><strong>工作原理</strong>：利用电容在一定的交流信号频率下产生的<strong>容抗</strong>来限制最大工作电流。<br>容抗：Xc=1/(2πfC)<br><img src="https://tse1-mm.cn.bing.net/th/id/OIP-C.3yIZgUAfpHlJ_RMq-7WrKQAAAA?w=191&amp;h=88&amp;c=7&amp;r=0&amp;o=5&amp;dpr=1.5&amp;pid=1.7" alt="电容容抗计算公式"><br><span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>为什么不用电阻降压：因为电阻消耗<strong>有功功率</strong>，存在发热问题；而电容消耗<strong>无功功率</strong>几乎不消耗能源，还不发热</li></ol><p><em>例如</em>在50Hz的工频条件下，一个1uF的电容所产生的容抗约为3180欧姆。当220V的交流电压加在电容器的两端，则流过电容的最大电流约为70mA。虽然流过电容的电流有70mA，但在<strong>电容器上并不产生功耗</strong>，因为如果电容是一个理想电容，则流过电容的电流为虚部电流，它所作的功为<strong>无功功率</strong>。<br>根据这个特点，我们如果在一个1uF的电容器上再串联一个阻性元件，则阻性元件两端所得到的电压和它所产生的功耗完全取决于这个阻性元件的特性。</p><p>容性无功功率在电网中被当作<strong>无功电源</strong>，感性无功功率在电网中被当作无功负载</p><p><strong>应用</strong>：将<strong>交流市电转换为低压直流</strong>的常规方法是采用变压器降压后再整流滤波，当受体积和成本等因素的限制时，最简单实用的方法就是采用电容降压式电源<br><img src="/images/%E5%B8%B8%E7%94%A8%E7%94%B5%E5%AD%90%E5%85%83%E5%99%A8%E4%BB%B6/2.jpg" alt="常用电路：阻容并联降压"></p><p><a href="#1"><strong>注意事项</strong></a></p><ol start="2"><li>滤波<br><strong>隔直通交：</strong><br>直流电频率f=0Hz；<table><tbody><tr><td bgcolor="#FF8C00">容抗随着频率的增加而减小</td></tr></tbody></table></li></ol><p><img src="https://img-blog.csdnimg.cn/2020062716070224.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjAwNTk5Mw==,size_16,color_FFFFFF,t_70" alt="电容阻抗-频率曲线图"><br><a href="https://blog.csdn.net/weixin_42005993/article/details/106983988?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E5%AE%B9%E6%8A%97%E9%9A%8F%E9%A2%91%E7%8E%87%20%E5%9B%BE&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-106983988.142%5Ev47%5Epc_rank_34_default_3,201%5Ev3%5Econtrol&amp;spm=1018.2226.3001.4187">电容阻抗-频率曲线理解blog</a></p><p>高通滤波器：并非把低频信号完全滤除，只是低频信号的幅度削减更大，高频信号幅度削减更小<br><img src="/images/%E5%B8%B8%E7%94%A8%E7%94%B5%E5%AD%90%E5%85%83%E5%99%A8%E4%BB%B6/1.jpg" alt="常用电路：阻容并联降压"></p><p><strong>选滤波电容的原则</strong>：选阻抗最低的电容</p><ol start="3"><li>延时<br>给电容充电时，电容的充电曲线并非一条直线，因此可以用作延时电路<br>下图是常用RC延时电路以及上电后的波形<br><img src="https://img-blog.csdn.net/2018071610145935?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05haXN1X2t1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="常用电路：RC延时电路"><br><img src="https://img-blog.csdn.net/20180716102844482?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L05haXN1X2t1bg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="RC延时电路的波形"><br>充电时间的公式：<table><tbody><tr><td color="#40E0D0">充电时间 T = - ln ( ( VCC - Vout ) / VCC ) * R * C </td></tr></tbody></table>从0.1Vout充电到0.9Vout需要时间2.2RC</li></ol><p>单片机波形，若想要给高电平信号一个延时，可以使用RC延时电路<br><img src="/images/%E5%B8%B8%E7%94%A8%E7%94%B5%E5%AD%90%E5%85%83%E5%99%A8%E4%BB%B6/2.jpg" alt="常用电路：RC延时电路"></p><ol start="4"><li><p>耦合<br>电容隔直通交，可以将我们<strong>需要的交流信号</strong>从前级电路近似无衰减地耦合到后级电路，将我们<strong>不需要的直流信号</strong>进行去耦（隔断）<br><img src="/images/%E5%B8%B8%E7%94%A8%E7%94%B5%E5%AD%90%E5%85%83%E5%99%A8%E4%BB%B6/3.jpg" alt="耦合电路示意图"></p></li><li><p>旁路<br>滤除高频交流信号<br><strong>常见模型</strong>：给单片机<font color="#FFFF00">供电</font>时，习惯性地在电源与地中间加一个0.1uf的小电容，这样，高频干扰信号会通过小电容流向地，使芯片免受高频信号的干扰<br><img src="/images/%E5%B8%B8%E7%94%A8%E7%94%B5%E5%AD%90%E5%85%83%E5%99%A8%E4%BB%B6/4.jpg" alt="旁路电容示意图"><br>且旁路电容一般都紧靠芯片（物理紧靠），如果电容距离芯片太原，效果将大打折扣（导线受噪声、电磁干扰影响产生高频信号）</p></li></ol><p>很多数据手册上，旁路电容通常是2个电容并联工作，且小电容更紧靠芯片，这是因为容值小的电容，有最高的谐振频率，能滤除更高频的电波<br><img src="/images/%E5%B8%B8%E7%94%A8%E7%94%B5%E5%AD%90%E5%85%83%E5%99%A8%E4%BB%B6/5.jpg" alt="旁路电容示意图2"><br><img src="https://img-blog.csdnimg.cn/img_convert/c639ff9baea7d8f9c3ca88fb993e94bb.png" alt="谐振频率计算公式"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/68da7ec83090bab228e5f7c3524ab5a9.png" alt="旁路电容示意图3"></p><hr><p><font face="黑体" size="6">电感</font><br>…Waiting</p><hr><p><font face="黑体" size="6">三极管</font><br>…Waiting</p><hr><p><font face="黑体" size="6">。。。</font><br>…Waiting</p><hr><div id="1">采用【电容降压】时应注意以下几点：</div>1. 根据负载的<font color="#FF0000">电流大小</font>和交流电的<font color="#FF0000">工作频率</font>选取适当的电容，而不是依据负载的电压和功率。  2. 限流电容必须采用无极性电容，绝对不能采用电解电容。而且电容的耐压须在400V以上。最理想的电容为铁壳油浸电容。  3. 电容降压不能用于大功率负载，因为不安全。  4. 电容降压不适合动态负载。  5. 同样，电容降压不适合容性和感性负载。  6. 当需要直流工作时，尽量采用半波整流。不建议采用桥式整流， 因为全波整流产生浮置的地，并在零线和火线之间产生高压，造成人体触电伤害。而且要满足恒定负载的条件。]]></content>
      
      
      <categories>
          
          <category> -电子电路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -电路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>try_catch</title>
      <link href="/2022/09/21/try-catch/"/>
      <url>/2022/09/21/try-catch/</url>
      
        <content type="html"><![CDATA[<p><font size="6"><strong>基本语法</strong></font></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">throw</span>  表达式<span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    语句组<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>异常类型<span class="token punctuation">)</span> <span class="token punctuation">{</span>    异常处理代码<span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>异常类型<span class="token punctuation">)</span> <span class="token punctuation">{</span>    异常处理代码<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>catch 可以有多个，但至少要有一个。</p><p>不妨把 try 和其后{}中的内容称作“try块”，把 catch 和其后{}中的内容称作“catch块”。</p><p>try…catch 语句的执行过程是：</p><ul><li>执行 try 块中的语句，如果执行的过程中没有异常拋出，那么执行完后就执行最后一个 catch 块后面的语句，所有 catch 块中的语句都不会被执行；</li><li>如果 try 块执行的过程中拋出了异常，那么拋出异常后立即跳转到第一个“异常类型”和拋出的异常类型匹配的 catch 块中执行（称作异常被该 catch 块“捕获”），执行完后再跳转到<strong>最后一个 catch 块后面</strong>继续执行。</li></ul><p><em><strong>示例</strong></em></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> m <span class="token punctuation">,</span>n<span class="token punctuation">;</span>    cin <span class="token operator">>></span> m <span class="token operator">>></span> n<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"before dividing."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span> n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//抛出int类型异常</span>        <span class="token keyword">else</span>            cout <span class="token operator">&lt;&lt;</span> m <span class="token operator">/</span> n <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"after dividing."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">double</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"catch(double) "</span> <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span>  endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token keyword">int</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"catch(int) "</span> <span class="token operator">&lt;&lt;</span> e <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"finished"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序的运行结果如下：<br>9 6↙<br>before dividing.<br>1.5<br>after dividing.<br>finished</p><p>说明当 n 不为 0 时，try 块中不会拋出异常。因此程序在 try 块正常执行完后，越过所有的 catch 块继续执行，catch 块一个也不会执行。</p><p>程序的运行结果也可能如下：<br>9 0↙<br>before dividing.<br>catch(int) -1<br>finished</p><p>当 n 为 0 时，try 块中会拋出一个整型异常。拋出异常后，try 块立即停止执行。该整型异常会被类型匹配的第一个 catch 块捕获，即进入catch(int e)块执行，该 catch 块执行完毕后，程序继续往后执行，直到正常结束。</p><p><strong>能够捕获任何异常的 catch 语句</strong><br><code>catch(...) {异常处理代码}</code></p><hr><p><font size="6"><strong>抛出“类”的异常</strong></font></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">CException</span><span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    string msg<span class="token punctuation">;</span>    <span class="token function">CException</span><span class="token punctuation">(</span>string s<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">msg</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">double</span> <span class="token function">Devide</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">,</span> <span class="token keyword">double</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>y <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token function">CException</span><span class="token punctuation">(</span><span class="token string">"devided by zero"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"in Devide"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> x <span class="token operator">/</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">CountTax</span><span class="token punctuation">(</span><span class="token keyword">int</span> salary<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>salary <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"counting tax"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"salary &lt; 0"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"tax counted"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> salary <span class="token operator">*</span> <span class="token number">0.15</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">double</span> f <span class="token operator">=</span> <span class="token number">1.2</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token function">CountTax</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        f <span class="token operator">=</span> <span class="token function">Devide</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"end of try block"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span>CException e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span>msg <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"f = "</span> <span class="token operator">&lt;&lt;</span> f <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"finished"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序的输出结果如下：<br>salary &lt; 0<br>tax counted<br>devided by zero<br>f=1.2<br>finished</p><p>拋出的异常是派生类的对象，而 catch 块的异常类型是基类，那么这两者也能够匹配，因为派生类对象也是基类对象。</p><hr><p><font size="6"><strong>C++标准异常类</strong></font><br>C++ 标准库中有一些类代表异常，这些类都是从 exception 类派生而来的。<br>bad_typeid、bad_cast、bad_alloc、ios_base::failure、out_of_range 都是 exception 类的派生类。<br>C++ 程序在碰到某些异常时，即使程序中没有写 throw 语句，也会自动拋出上述异常类的对象。<br>这些异常类还都有名为 what 的成员函数，返回字符串形式的异常描述信息。<br>使用这些异常类需要<table><tbody><tr><td bgcolor="#FFA500">包含头文件<strong>stdexcept</strong></td></tr></tbody></table></p><p><em>以下是自己写程序时经常遇到的错误</em><br>1.bad_alloc<br>在用 new 运算符进行动态内存分配时，如果没有足够的内存，则会引发此异常。程序示例如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span> <span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token number">0x7fffffff</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//无法分配这么多空间，会抛出异常</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span>bad_alloc <span class="token operator">&amp;</span> e<span class="token punctuation">)</span>  <span class="token punctuation">{</span>        cerr <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序的输出结果如下：<br>bad allocation<br>ios_base::failure</p><p>在默认状态下，输入输出流对象不会拋出此异常。如果用流对象的 exceptions 成员函数设置了一些标志位，则在出现打开文件出错、读到输入流的文件尾等情况时会拋出此异常。此处不再赘述。</p><hr><p>2.out_of_range<br>用 vector 或 string 的 at 成员函数根据下标访问元素时，如果下标越界，则会拋出此异常。例如：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdexcept></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;string></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">v</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        v<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//拋出 out_of_range 异常</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span>out_of_range <span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cerr <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    string s <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span> c <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//拋出 out_of_range 异常</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span>out_of_range <span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cerr <span class="token operator">&lt;&lt;</span> e<span class="token punctuation">.</span><span class="token function">what</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序的输出结果如下：<br>invalid vector <t> subscript<br>invalid string position</t></p><p>如果将v.at(100)换成v[100]，将s.at(100)换成s[100]，程序就<strong>不会引发异常（但可能导致程序崩溃）</strong>。</p><table><tbody><tr><td bgcolor="#87CEFA">因为 at 成员函数会检测下标越界并拋出异常，而 operator[] 则不会。</td></tr></tbody></table>operator [] 相比 at 的好处就是不用判断下标是否越界，因此**执行速度更快。**]]></content>
      
      
      <categories>
          
          <category> C++项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP-Day5</title>
      <link href="/2022/09/21/DP-Day5/"/>
      <url>/2022/09/21/DP-Day5/</url>
      
        <content type="html"><![CDATA[<p><font face="微软雅黑" size="6" color="#A52A2A">第一题</font><br>给你一个大小为 m x n 的网格和一个球。球的起始坐标为 [startRow, startColumn] 。<br>你可以将球移到在四个方向上相邻的单元格内（可以穿过网格边界到达网格之外）。你<strong>最多</strong>可以移动 maxMove 次球。<br>给你五个整数 m、n、maxMove、startRow 以及 startColumn ，找出并返回可以将球移出边界的路径数量。<br>因为答案可能非常大，返回对 10^9 + 7 取余 后的结果。<br><img src="/images/DP-Day5/1.png" alt="示意图"><br><a href="https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/r8wmbi/">原题链接</a></p><p><strong>自己的思路</strong></p><p>原作者解析<br>1、能否使用动态规划求解？<br>2、两种「动态规划」求解方法<br>     <span class="github-emoji"><span>☝</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/261d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>根据经验猜一个「状态定义」，然后根据「状态定义」去推导一个「状态转移方程」。（<font color="#7FFF00">经验解法</font>）<br>     <span class="github-emoji"><span>✌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/270c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>先写一个「记忆化搜索」解法，再将「记忆化搜索」改写成「动态规划」。（<font color="#7FFF00">技巧解法</font>）</p><table><tbody><tr><td bgcolor="#00BFFF">**技巧解法**</td></tr></tbody></table>「技巧解法」是将「记忆化搜索」翻译成「动态规划」1、得出「记忆化搜索」的DFS函数<span class="github-emoji"><span>1⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0031-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>函数的参数和返回值 <span class="github-emoji"><span>2⃣</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/0032-20e3.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>函数中会变化的参数**重点放在 DFS 函数签名中的「可变参数」与「返回值」**<p><em>以本题为例</em>：<br>DFS函数：</p><pre><code>int dfs(int m, int n, int x, int y, int k) {}</code></pre><p>可变变量：(x,y) 代表当前所在的位置，k 代表最多的移动次数<br>返回值：代表路径数量。</p><p>设计数组存储对应信息：<br>二维数组 f[][]作为 DP 数组：<br>第一维代表 DFS 可变参数中的 (x,y)(x,y) 所对应 indexindex。取值范围为 [0, m*n)<br>第二维代表 DFS 可变参数中的 kk。取值范围为 [0,N]<br>因此，状态被定义为：f[i][j] 代表从位置 i 出发，可用步数<font color="#FF0000">不超过 j</font> 时的路径数量。</p><p>2、推断出状态定义后，从「最后一步」来推导出「转移方程」<br>(x,y) 出发的路径数量 = 上方 (x-1,y) 的路径数量 + 下方 (x+1,y) 的路径数量 + 左方 (x,y-1) 的路径数量 + 右方 (x,y+1) 的路径数量<br>即f[(x,y)][step]=f[(x−1,y)][step−1]+f[(x+1,y)][step−1]+f[(x,y−1)][step−1]+f[(x,y+1)][step−1]<br>从转移方程中我们发现，更新 f[i][j] 依赖于 f[x][j-1]，因此我们转移过程中需要将最大移动步数（step）进行从小到大枚举。<br>至此，已推导出「状态转移方程」</p><p>3、找到「有效值」作为初始化状态<br>因为整个转移过程是一个累加过程，如果没有一些有效的状态（非零值）进行初始化的话，整个递推过程并没有意义。<br>在本题中，如果已经位于矩阵边缘的时候，我们可以一步跨出矩阵，算作一条路径。<br>同时，由于我们能够往四个方向进行移动，因此不同的边缘格子会有不同数量的路径。<br>!<img src="/images/DP-Day5/2.png" alt="示意图"></p><p><strong>原作者的代码</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> mod <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token number">1e9</span><span class="token operator">+</span><span class="token number">7</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> m<span class="token punctuation">,</span> n<span class="token punctuation">,</span> N<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findPaths</span><span class="token punctuation">(</span><span class="token keyword">int</span> _m<span class="token punctuation">,</span> <span class="token keyword">int</span> _n<span class="token punctuation">,</span> <span class="token keyword">int</span> _N<span class="token punctuation">,</span> <span class="token keyword">int</span> _i<span class="token punctuation">,</span> <span class="token keyword">int</span> _j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        m <span class="token operator">=</span> _m<span class="token punctuation">;</span> n <span class="token operator">=</span> _n<span class="token punctuation">;</span> N <span class="token operator">=</span> _N<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// f[i][j] 代表从 idx 为 i 的位置出发，移动步数不超过 j 的路径数量</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m <span class="token operator">*</span> n<span class="token punctuation">]</span><span class="token punctuation">[</span>N <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 初始化边缘格子的路径数量</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> f<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 定义可移动的四个方向</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dirs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 从小到大枚举「可移动步数」</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> step <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> step<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 枚举所有的「位置」</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> m <span class="token operator">*</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token function">parseIdx</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token function">parseIdx</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> d <span class="token operator">:</span> dirs<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> nx <span class="token operator">=</span> x <span class="token operator">+</span> d<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ny <span class="token operator">=</span> y <span class="token operator">+</span> d<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 如果位置有「相邻格子」，则「相邻格子」参与状态转移</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>nx <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nx <span class="token operator">&lt;</span> m <span class="token operator">&amp;&amp;</span> ny <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> ny <span class="token operator">&lt;</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>step<span class="token punctuation">]</span> <span class="token operator">+=</span> f<span class="token punctuation">[</span><span class="token function">getIndex</span><span class="token punctuation">(</span>nx<span class="token punctuation">,</span> ny<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>step <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                        f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>step<span class="token punctuation">]</span> <span class="token operator">%=</span> mod<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 最终结果为从起始点触发，最大移动步数不超 N 的路径数量</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span><span class="token function">getIndex</span><span class="token punctuation">(</span>_i<span class="token punctuation">,</span> _j<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 为每个「边缘」格子，添加一条路径</span>    <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token function">getIndex</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> step <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> step <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> step<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            f<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">[</span>step<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将 (x, y) 转换为 index</span>    <span class="token keyword">int</span> <span class="token function">getIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> x <span class="token operator">*</span> n <span class="token operator">+</span> y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 将 index 解析回 (x, y)</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">parseIdx</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>idx <span class="token operator">/</span> n<span class="token punctuation">,</span> idx <span class="token operator">%</span> n<span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//作者：宫水三叶</span><span class="token comment" spellcheck="true">//链接：https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/r8doce/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> 记忆化搜索 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无痛自律</title>
      <link href="/2022/09/21/%E6%97%A0%E7%97%9B%E8%87%AA%E5%BE%8B/"/>
      <url>/2022/09/21/%E6%97%A0%E7%97%9B%E8%87%AA%E5%BE%8B/</url>
      
        <content type="html"><![CDATA[<p><font face="黑体" size="6"><strong>首要原则</strong></font><br>不能勉强，否则难以坚持，并会伴随巨大的挫败感<br><strong>技巧</strong><br>普雷马克（Premack）原理：</p><table><tbody><tr><td bgcolor="#00FFFF">用高频行为（喜欢的行为）作为低频行为（不喜欢的行为）的有效强化物</td></tr></tbody></table>*举例*把喜欢的歌曲留到运动或学习时间听喜欢的饮料零食留到学习时候吃喜欢的视频留到吃健康餐的时候看。。<p>总而言之，干不喜欢做的事情时，搭配一件喜欢的事<span class="github-emoji"><span>❤</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><hr><p><font face="黑体" size="6"><strong>早睡早起。。</strong></font><br>根据某一研究，人类潜意识地把<table><tbody><tr><td bgcolor="#FFFF00">中午12点作为一天的中间点</td></tr></tbody></table><br>因此早期人心理上觉得<strong>时间充足</strong></p><hr><p><font face="黑体" size="6"><strong>专业课的学习tips</strong></font></p><ol><li><p>减轻心理负担<br>坚持每天学习7小时，放弃以“达成xx目标”量化一天的成就。<br>每天都能做到一定的学习时间，即使没有达到目标成果，也没什么心理负担</p></li><li><p>看书时听喜欢的音乐<br>平时不要听，即使听歌时会走神，也没有关系，学习够足够的时间就行</p></li><li><p>学习时用喜欢的香水<br>能让自己更开心<br>除此之外，还能促进记忆————特异性编码，考试时用同样的香水，能够帮助回忆</p></li><li><p>多本书一起看，腻了换一本</p></li></ol><p><strong>小结</strong><br>其实看上面4点，会有<em>无效努力</em>的side effect，只关注时间可能是在感动自己<br>不过既然是无痛学习，在平时积累时间，即使每天只有半小时，总比没学好<span class="github-emoji"><span>☺</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br>付出过的努力过的，总会体现出来的<span class="github-emoji"><span>👊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f44a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br>最重要的是心理上的心安理得，减少内耗</p><p><font face="黑体" size="6"><strong>自律不是终极目标，Maximum Happiness才是<span class="github-emoji"><span>✌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/270c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>~</strong></font></p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 豆瓣 </tag>
            
            <tag> 心理学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用md格式</title>
      <link href="/2022/09/21/%E5%B8%B8%E7%94%A8md%E6%A0%BC%E5%BC%8F/"/>
      <url>/2022/09/21/%E5%B8%B8%E7%94%A8md%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><font size="6" face="黑体"><strong>标题</strong></font></p><blockquote><p>&lt;font size=6 face=”黑体”&gt;**<br><font size="6" face="黑体"><strong>示例</strong></font><br>&lt;font face=”微软雅黑” size=6 color=#A52A2A&gt;**<br><font face="微软雅黑" size="6" color="#A52A2A"><strong>示例</strong></font></p></blockquote><hr><p><font size="6" face="黑体"><strong>字体颜色</strong></font></p><table><thead><tr><th>效果</th><th>名字</th><th>代码</th></tr></thead><tbody><tr><td><font color="#FF0000">文字</font></td><td>红色</td><td>#FF0000</td></tr><tr><td><font color="#008000">文字</font></td><td>深绿</td><td>#008000</td></tr><tr><td><font color="#00BFFF">文字</font></td><td>深天蓝</td><td>#00BFFF</td></tr><tr><td><font color="#FFD700">文字</font></td><td>金色</td><td>#FFD700</td></tr><tr><td><font color="#FFA500">文字</font></td><td>橘色</td><td>#FFA500</td></tr></tbody></table><blockquote><p>代码：&lt;font color=#&gt;</p></blockquote><hr><p><font size="6" face="黑体"><strong>文字背景色</strong></font></p><table>  <tbody><tr>    <td>颜色</td>    <td>名字</td>    <td>代码</td>  </tr>  <tr>    <td bgcolor="#FA8072"> </td>    <td>三文鱼</td>    <td>#FA8072</td>  </tr>  <tr>    <td bgcolor="#FF8C00"> </td>    <td>深橙色</td>    <td>#FF8C00</td>  </tr>  <tr>    <td bgcolor="#FFA500"> </td>    <td>橙子</td>    <td>#FFA500</td>  </tr>  <tr>    <td bgcolor="#FFFF00"> </td>    <td>黄色</td>    <td>#FFFF00</td>  </tr>  <tr>    <td bgcolor="#7FFF00"> </td>    <td>黄绿色</td>    <td>#7FFF00</td>  </tr>  <tr>    <td bgcolor="#00FFFF"> </td>    <td>青色</td>    <td>#00FFFF</td>  </tr>  <tr>    <td bgcolor="#40E0D0"> </td>    <td>绿松石</td>    <td>#40E0D0</td>  </tr>  <tr>    <td bgcolor="#00BFFF"> </td>    <td>深蓝</td>    <td>#00BFFF</td>  </tr>   <tr>    <td bgcolor="#FFB6C1"> </td>    <td>浅粉红</td>    <td>#FFB6C1</td>  </tr>   <tr>    <td bgcolor="#F4A460"> </td>    <td>沙棕</td>    <td>#F4A460</td>  </tr></tbody></table><blockquote><p>代码：&lt;table&gt;&lt;tr&gt;&lt;td bgcolor=# &gt;<br>      &lt;/td&gt;</p></blockquote><hr><p><font size="6" face="黑体"><strong>表情符号</strong></font></p><table><thead><tr><th>符号</th><th>代码</th><th>符号</th><th>代码</th><th>符号</th><th>代码</th></tr></thead><tbody><tr><td><span class="github-emoji"><span>❤</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:heart:</code></td><td><span class="github-emoji"><span>💙</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f499.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:blue_heart:</code></td><td><span class="github-emoji"><span>💔</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f494.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:broken_heart:</code></td></tr><tr><td><span class="github-emoji"><span>✨</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2728.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:sparkles:</code></td><td><span class="github-emoji"><span>😊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:blush:</code></td><td><span class="github-emoji"><span>☺</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/263a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:relaxed:</code></td></tr><tr><td><span class="github-emoji"><span>😇</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f607.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:innocent:</code></td><td><span class="github-emoji"><span>😅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:sweat_smile:</code></td><td><span class="github-emoji"><span>😓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f613.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:sweat:</code></td></tr><tr><td><span class="github-emoji"><span>💧</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a7.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:droplet:</code></td><td><span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:sob:</code></td><td><span class="github-emoji"><span>😱</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f631.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:scream:</code></td></tr><tr><td><span class="github-emoji"><span>😡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f621.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:rage:</code></td><td><span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:question:</code></td><td><span class="github-emoji"><span>❗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:exclamation:</code></td></tr><tr><td><span class="github-emoji"><span>💦</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a6.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:sweat_drops:</code></td><td><span class="github-emoji"><span>👍</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f44d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:thumbsup:</code></td><td><span class="github-emoji"><span>👎</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f44e.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:thumbsdown\:</code></td></tr><tr><td><span class="github-emoji"><span>👊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f44a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:punch:</code></td><td><span class="github-emoji"><span>✌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/270c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:v:</code></td><td><span class="github-emoji"><span>🙏</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f64f.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:pray:</code></td></tr><tr><td><span class="github-emoji"><span>➡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/27a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:arrow_right:</code></td><td><span class="github-emoji"><span>🚫</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f6ab.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:no_entry_sign:</code></td><td><span class="github-emoji"><span>🆚</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f19a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:vs:</code></td></tr><tr><td><span class="github-emoji"><span>❗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2757.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:heavy_exclamation_mark:</code></td><td><span class="github-emoji"><span>❌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:x:</code></td><td><span class="github-emoji"><span>✅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:white_check_mark:</code></td></tr><tr><td><span class="github-emoji"><span>🔗</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f517.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:link:</code></td><td><span class="github-emoji"><span>📌</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4cc.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:pushpin:</code></td><td><span class="github-emoji"><span>💡</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a1.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></td><td><code>:bulb:</code></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP-Day4</title>
      <link href="/2022/09/15/DP-Day4/"/>
      <url>/2022/09/15/DP-Day4/</url>
      
        <content type="html"><![CDATA[<p><font face="微软雅黑" size="6" color="#A52A2A">第一题</font><br>给你一个<em>互不相同</em>的整数数组，其中&nbsp;locations[i]&nbsp;表示第&nbsp;i&nbsp;个城市的位置。<br>同时给你&nbsp;start，finish&nbsp;和&nbsp;fuel&nbsp;分别表示出发城市、目的地城市和你初始拥有的汽油总量<br>每一步中，如果你在城市 i&nbsp;，你可以选择任意一个城市 j&nbsp;，满足 &nbsp;j != i&nbsp;且&nbsp;0 &lt;= j &lt; locations.length&nbsp;，并移动到城市&nbsp;j&nbsp;。<br>从城市&nbsp;i&nbsp;移动到&nbsp;j&nbsp;消耗的汽油量为&nbsp;|locations[i] - locations[j]|，|x|&nbsp;表示&nbsp;x&nbsp;的绝对值。<br>请注意，&nbsp;fuel&nbsp;任何时刻都&nbsp;不能&nbsp;为负，且你&nbsp;可以&nbsp;经过任意城市超过一次（包括&nbsp;start&nbsp;和&nbsp;finish&nbsp;）。<br>请你返回从&nbsp;start&nbsp;到&nbsp;finish&nbsp;所有可能路径的数目。<br>由于答案可能很大， 请将它对&nbsp;10^9 + 7&nbsp;取余后返回。<br><img src="/images/DP-Day4/1.png" alt="题目"><br><a href="https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/r8pzo1/">链接在这里</a></p><hr><p><strong>原思路</strong><br>定义变量：b、e分别表示每一次移动的起点与终点，每次移动step步</p><p><strong>对比作者的思路</strong><br>路径问题-&gt;DFS-&gt;DFS问题为指数级别复杂度-&gt;记忆化搜索</p><p><font color="#FF0000" size="5">实现DFS的通常步骤</font><br>1、设计好递归函数的「入参」和「出参」<br>2、设置好递归函数的出口（Base Case）<br>3、编写「最小单元」处理逻辑<br>其中，最重要的是要找出Base Case，也就是确定<strong>在什么情况下，算一次有效/无效</strong><br>本题的有效情况：当前所在位置为finish<br>本题无效情况：1、油量消耗完，且当前位置不在finish 2、油量不为0，但无法移动到任何位置<br>接着，添加<strong>记忆化搜索</strong><br>记忆化搜索就是使用变量（通常是数组）记录当前状态，也就是中间结果<br>我们用 cache[i][fuel] 代表从位置 i 出发，当前剩余的油量为 fuel 的前提下，到达<table><tbody><tr><td bgcolor="7FFFD4">目标位置</td></tr></tbody></table>的「路径数量」。<br>之所以能采取「缓存中间结果」这样的做法，是因为「在 i 和 fuel 确定的情况下，其到达目的地的路径数量是<table><tbody><tr><td bgcolor="#FFD700">唯一确定</td></tr></tbody></table>的」。<br><em>与自己的思路区别：作者的中间状态（最小单元）有2个变量：fuel和起点，也就是自己定义的step和b<br>比自己定义的中间状态少了一个变量<br>自己定义的三维数组存储的是</em><strong>是否存在路径</strong>*<br>而作者定义的二维数组存储了<em><strong>成立的路径数量</strong></em><br>我想作者如此定义中间状态的原因主要参考了本题的有效情况（到达finish）和所需output<br>所以以后定义中间状态变量时遇到维度过多的情况，可以考虑使用“数量”代替“存在”，利用变量的取值减少一个维度*</p><table><tbody><tr><td bgcolor="#1E90FF">DFS（深度优先搜索）的框架</td></tr></tbody></table><pre><code>function dfs(当前状态){    if(当前状态 == 目的状态){        ···    }    for(···寻找新状态){        if(状态合法){            vis[访问该点]；            dfs(新状态);            ?是否需要恢复现场-&gt;vis[恢复访问]        }     }    if(找不到新状态){        ···    }}//CSDN博主「HeartFireY」的原创文章//原文链接：https://blog.csdn.net/yanweiqi1754989931/article/details/109603384//制作很精美的博文（DFS介绍）</code></pre><p><strong>作者宫水三叶的代码</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> mod <span class="token operator">=</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 缓存器：用于记录「特定状态」下的结果</span>    <span class="token comment" spellcheck="true">// cache[i][fuel] 代表从位置 i 出发，当前剩余的油量为 fuel 的前提下，到达目标位置的「路径数量」</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cache<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countRoutes</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ls<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> fuel<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> ls<span class="token punctuation">.</span>length<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 初始化缓存器</span>        <span class="token comment" spellcheck="true">// 之所以要初始化为 -1</span>        <span class="token comment" spellcheck="true">// 是为了区分「某个状态下路径数量为 0」和「某个状态尚未没计算过」两种情况</span>        cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>fuel <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Arrays<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span>cache<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token keyword">return</span> <span class="token function">dfs</span><span class="token punctuation">(</span>ls<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> fuel<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**     * 计算「路径数量」     * @param ls 入参 locations     * @param u 当前所在位置（ls 的下标）     * @param end 目标哦位置（ls 的下标）     * @param fuel 剩余油量     * @return 在位置 u 出发，油量为 fuel 的前提下，到达 end 的「路径数量」     */</span>    <span class="token keyword">int</span> <span class="token function">dfs</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ls<span class="token punctuation">,</span> <span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> fuel<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果缓存器中已经有答案，直接返回————记忆化搜索</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cache<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>fuel<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> cache<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>fuel<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token keyword">int</span> n <span class="token operator">=</span> ls<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// base case 1：如果油量为 0，且不在目标位置</span>        <span class="token comment" spellcheck="true">// 将结果 0 写入缓存器并返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fuel <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> u <span class="token operator">!=</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cache<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>fuel<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                 <span class="token comment" spellcheck="true">// base case 2：油量不为 0，且无法到达任何位置</span>        <span class="token comment" spellcheck="true">// 将结果 0 写入缓存器并返回</span>        <span class="token keyword">boolean</span> hasNext <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> u<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> need <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>ls<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">-</span> ls<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>fuel <span class="token operator">>=</span> need<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    hasNext <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>fuel <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>hasNext<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cache<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>fuel<span class="token punctuation">]</span> <span class="token operator">=</span> u <span class="token operator">==</span> end <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> cache<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>fuel<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 计算油量为 fuel，从位置 u 到 end 的路径数量</span>        <span class="token comment" spellcheck="true">// 由于每个点都可以经过多次，如果 u = end，那么本身就算一条路径</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> u <span class="token operator">==</span> end <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> u<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> need <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>ls<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> ls<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>fuel <span class="token operator">>=</span> need<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    sum <span class="token operator">+=</span> <span class="token function">dfs</span><span class="token punctuation">(</span>ls<span class="token punctuation">,</span> i<span class="token punctuation">,</span> end<span class="token punctuation">,</span> fuel <span class="token operator">-</span> need<span class="token punctuation">)</span><span class="token punctuation">;</span>                    sum <span class="token operator">%=</span> mod<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        cache<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>fuel<span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">;</span>        <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><font size="5">简化Base Case</font><br>简化Base Case就是要深入挖掘有/无效情况<br>原先定义的无效情况：下一步（是一步）无法达到finish<br>其实，如果当前位置经计算无法达到finish，那么任移动几步都无法达到finish<br>代码变化：</p><pre class="line-numbers language-java"><code class="language-java">        <span class="token comment" spellcheck="true">// 如果一步到达不了，说明从位置 u 不能到达 end 位置</span>        <span class="token comment" spellcheck="true">// 将结果 0 写入缓存器并返回</span>        <span class="token keyword">int</span> need <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>ls<span class="token punctuation">[</span>u<span class="token punctuation">]</span> <span class="token operator">-</span> ls<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>need <span class="token operator">></span> fuel<span class="token punctuation">)</span> <span class="token punctuation">{</span>            cache<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">[</span>fuel<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//上述代码将替换原先两个Base Case</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><font face="微软雅黑" size="4" color="#0000FF">进阶:动态规划求解</font><br><span class="github-emoji"><span>❓</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2753.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>如何将本题使用<font color="#FF0000">动态规划</font>的方式求解？<br><strong>任何「记忆化搜索」都能改成「动态规划」。</strong></p><table><tbody><tr><td bgcolor="#1E90FF">如何直接将「记忆化搜索」改成「动态规划」。</td></tr></tbody></table>使用这种技巧，你将不需要去猜「状态定义」和根据「状态定义」推导「状态转移方程」。1、关注DFS函数的参数```int dfs(int[] ls, int u, int end, int fuel) {}```其中，ls(location)和end(finish)在DFS过程中不会改变而u和fuel分别表示当前位置和当前油量，是<font color="#FF0000">可变参数</font>那么，定义二维数组f，分别表示两个可变参数第一维代表当前位置，第二维代表剩余油量数组存储DFS的返回值（路径数量）<p>2、翻译出「状态转移方程」<br>第一步的“翻译”工作后，我们得到了「动态规划」的「状态定义」。<br>所谓的「状态转移方程」其实就是指如何从一个状态转移到另外一个状态。<br>而我们的 DFS 主逻辑就是完成这个转移的。<br>DFS 中的主逻辑很简单：枚举所有的位置，看从当前位置 u 出发，可以到达的位置有哪些。<br>于是我们很容易就可以得出状态转移方程：<br>f[i][fuel]=f[i][fuel]+f[k][fuel-need]<br>k 代表计算位置 i 油量 fuel 的状态时枚举的「下一位置」，need 代表从 i 到达 k 需要的油量。<br> i 和 k 并无严格的大小关系，而 fuel 和 fuel-need 具有严格的大小关系（fuel ≥ fuel−need）。<br>因此我们需要先从小到大枚举油量这一维。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">int</span> mod <span class="token operator">=</span> <span class="token number">1000000007</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countRoutes</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ls<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token keyword">int</span> fuel<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> ls<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// f[i][j] 代表从位置 i 出发，当前油量为 j 时，到达目的地的路径数</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>fuel <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 对于本身位置就在目的地的状态，路径数为 1</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> fuel<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 从状态转移方程可以发现 f[i][fuel]=f[i][fuel]+f[k][fuel-need]</span>        <span class="token comment" spellcheck="true">// 在计算 f[i][fuel] 的时候依赖于 f[k][fuel-need]</span>        <span class="token comment" spellcheck="true">// 其中 i 和 k 并无严格的大小关系</span>        <span class="token comment" spellcheck="true">// 而 fuel 和 fuel-need 具有严格大小关系：fuel >= fuel-need</span>        <span class="token comment" spellcheck="true">// 因此需要先从小到大枚举油量</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> cur <span class="token operator">&lt;=</span> fuel<span class="token punctuation">;</span> cur<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">int</span> need <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>ls<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> ls<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">>=</span> need<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">+=</span> f<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>cur<span class="token operator">-</span>need<span class="token punctuation">]</span><span class="token punctuation">;</span>                            f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">%=</span> mod<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">[</span>fuel<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//作者：宫水三叶</span><span class="token comment" spellcheck="true">//链接：https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/r8n0h2/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>总结</strong><br>整个过程：<br>1、从 DFS 方法签名出发。分析哪些入参是可变的，将其作为 DP 数组的<font color="#FF0000">维度</font>；将返回值作为 DP 数组的<font color="#FF0000">存储值</font>。<br>2、从 DFS 的主逻辑可以抽象中单个状态的计算方法。</p><p>其中第一点对应了「动态规划」的「状态定义」，第二点对应了「动态规划」的「状态方程转移」。</p><p>作者对这几章练习的小结<br>两种求解「动态规划」问题的方法：<br>1、根据经验猜一个「状态定义」，然后根据「状态定义」去推导一个「状态转移方程」。<br>2、先写一个「记忆化搜索」解法，再将「记忆化搜索」改写成「动态规划」。</p><p>能够去猜「状态定义」或者使用「记忆化搜索」求解，都有一个大前提：<strong>问题本身具有无效性。</strong></p><p>如果遇到一道你从来没接触过的题目时，建议先想想「记忆化搜索」该如何实现，然后反推出「动态规划」。<br>这里说的想想「记忆化搜索」该如何实现，不需要真正动手实现一个「记忆化搜索」解法，<br>而只需要想清楚，如果使用「记忆化搜索」的话，我的 DFS 函数参数和返回值如何设计即可。</p>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> 记忆化搜索 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP-Day3</title>
      <link href="/2022/09/14/DP-Day3/"/>
      <url>/2022/09/14/DP-Day3/</url>
      
        <content type="html"><![CDATA[<p><font face="微软雅黑" size="6" color="#A52A2A">第一题</font><br>给你一个 n x n 的<em>方形</em>整数数组&nbsp;matrix ，请你找出并返回通过 matrix 的<strong>下降路径</strong>的<strong>最小和</strong>。<br>下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。<br>在下一行选择的元素和当前行所选元素最多相隔一列（即位于正下方或者沿对角线向左或者向右的第一个元素）。<br>具体来说，位置 (row, col) 的下一个元素应当是 (row + 1, col - 1)、(row + 1, col) 或者 (row + 1, col + 1) 。<br><img src="/images/DP-Day3/1.jpg" alt="下降最小路径和1"><br><a href="https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/r85adr/">链接在这里！</a></p><hr><p><strong>思路</strong>：蛮简单的感觉，用上一道题的方法，直接更改matrix，节约空间（但是直接更改原数据十分危险）</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minFallingPathSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> matrix<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m<span class="token operator">=</span>matrix<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//矩阵的行、列</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">int</span> lft<span class="token punctuation">,</span>mid<span class="token punctuation">,</span>rht<span class="token punctuation">;</span>                lft<span class="token operator">=</span><span class="token punctuation">(</span>j<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">?</span>matrix<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">:</span>INT_MAX<span class="token punctuation">;</span>                mid<span class="token operator">=</span>matrix<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                rht<span class="token operator">=</span><span class="token punctuation">(</span>j<span class="token operator">!=</span>m<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">?</span>matrix<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">:</span>INT_MAX<span class="token punctuation">;</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>lft<span class="token punctuation">,</span>mid<span class="token punctuation">)</span><span class="token punctuation">;</span>                matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>matrix<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>rht<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//找到最后一行最小的路径值</span>        <span class="token keyword">int</span> ans<span class="token operator">=</span>INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            ans<span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span>matrix<span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font face="微软雅黑" size="4" color="#0000FF">原作者宫水三叶的解析</font><br>其实细看可以发现，自己的解法相当于作者<strong>动态规划（基于定义）</strong>的解法<br>还有一个复杂度较高的解法：</p><blockquote><p><font color="#FF0000" size="4">基于起点</font>解法的原理：<br>起点任选，每一个起点都存在最小路径，那么相当于把问题拆分成两步<br>1、找到一个起点u的最小路径——find函数<br>2、遍历所有找到的最小路径，找出最小点——for(遍历所有u){find(u,)}<br>整套算法时间复杂度O(n^3)</p></blockquote><p>那么就从理论上学习一下自己写的代码吧！<br><font color="#FF0000" size="4">动态规划（基于定义）</font><br>观察上一个解法的步骤：1、枚举起点 2、DP求最小路径和(find函数)<br>DP的复杂程度无法优化，那么我们选择优化枚举的过程</p><blockquote><p>直接从 DP 定义出发，进行转移即可。<br>定义 f[i][j]为到达位置 (i,j) 的最小路径和。<br>那么最终答案为所有 f[n-1][i]的最小值，i的取值范围为 [0,n)。<br>代表最小路径的结尾可能是最后一行的任意位置。</p></blockquote><hr><p><font face="微软雅黑" size="6" color="#A52A2A">第二题</font><br>给你一个&nbsp;n x n 整数矩阵&nbsp;arr&nbsp;，请你返回 非零偏移下降路径 数字和的最小值。<br>非零偏移下降路径 定义为：从&nbsp;arr 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。<br><img src="/images/DP-Day3/2.png" alt="下降路径最小和2"></p><p><em>代码最后的注释包含了本人做这题的心路历程，其实这题很简单</em></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> y<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token operator">*</span>n<span class="token operator">+</span>y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">getRow</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token operator">/</span>n<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//注意整除符号不要写成转义符号！</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">getCol</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span><span class="token keyword">int</span> n<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> x<span class="token operator">%</span>n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">minFallingPathSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n<span class="token operator">=</span>grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> f<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> g<span class="token punctuation">[</span>n<span class="token operator">*</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">else</span>                <span class="token punctuation">{</span>                    <span class="token keyword">int</span> min<span class="token operator">=</span>INT_MAX<span class="token punctuation">;</span>                    <span class="token keyword">int</span> wih<span class="token punctuation">;</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> wht<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>wht<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>wht<span class="token operator">++</span><span class="token punctuation">)</span>                    <span class="token punctuation">{</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>wht<span class="token operator">==</span>j<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>wht<span class="token punctuation">]</span><span class="token operator">&lt;</span>min<span class="token punctuation">)</span> <span class="token punctuation">{</span>min<span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>wht<span class="token punctuation">]</span><span class="token punctuation">;</span>wih<span class="token operator">=</span>wht<span class="token punctuation">;</span><span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                    f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>min<span class="token operator">+</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    g<span class="token punctuation">[</span><span class="token function">getId</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">getId</span><span class="token punctuation">(</span>i<span class="token number">-1</span><span class="token punctuation">,</span>wih<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">/*else if(j==0) f[i][j]=f[i-1][j+1]+grid[i][j];//rht                else if(j==n-1) f[i][j]=f[i-1][j-1]+grid[i][j];//left                else                 {                    int left=f[i-1][j-1]+grid[i][j];                    int rht=f[i-1][j+1]+grid[i][j];                    f[i][j]=min(left,rht);                }                */</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//find min</span>        <span class="token keyword">int</span> min<span class="token operator">=</span>INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">int</span> num<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>min<span class="token punctuation">)</span>            <span class="token punctuation">{</span>                min<span class="token operator">=</span>f<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                num<span class="token operator">=</span>i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>         <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//print(reverse)</span>        <span class="token keyword">int</span> row<span class="token punctuation">;</span>        <span class="token keyword">int</span> col<span class="token punctuation">;</span>        count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>count<span class="token operator">&lt;</span>n<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">int</span> id<span class="token punctuation">;</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                id<span class="token operator">=</span><span class="token function">getId</span><span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">,</span>num<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>                row<span class="token operator">=</span><span class="token function">getRow</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>                col<span class="token operator">=</span><span class="token function">getCol</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>                cout<span class="token operator">&lt;&lt;</span>grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>            <span class="token keyword">else</span>            <span class="token punctuation">{</span>                id<span class="token operator">=</span>g<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">;</span>                row<span class="token operator">=</span><span class="token function">getRow</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>                col<span class="token operator">=</span><span class="token function">getCol</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>                cout<span class="token operator">&lt;&lt;</span>grid<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> min<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/*输出：看懂别人写的和自己复现是完全不一样的错误：真的不知道哪里出错，也遇到了评论区的问题“自己进入了个思路误区：dp[i][j] 更新为了上一层对应得坐标加上当前层得最小值， 正确得应该是上一层得最小值，加上当前层的值得最小更新dp[i][j]”，但改了还是出错，和原来没区别好吧，题目理解错了，不是只能取相邻的点反思：忘记了前几天的滚动数组，果然还是不能偷懒，要用hexo记录*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><font face="微软雅黑" size="4" color="#0000FF">原作者宫水三叶的解析</font><br>如何简化这个问题？<br>同样按照上一道题的步骤<br><strong>首先拆分解法的步骤</strong><br>1、DP状态转移，共需转移n*n个状态<br>2、转移时需要枚举上一行的所有列<br>因为DP无法优化，所以只能优化第二步。<br><em>那怎么优化枚举呢</em><br>细想就可以发现，当我们在计算某行的状态值的时候，只会用到「上一行」的两个值:<em>最小值</em>和<em>次小值</em>。<br>因为我们只需要最小和，但考虑到前后元素不能有相同的列数，所以当前[i,j]位置最小的路径只考虑最小值和次小值即可<br><img src="/images/DP-Day3/3.png" alt="示意图"></p><p><em><strong>看对应代码</strong></em></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minFallingPathSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (i,j)位置在原问题的解</span>        <span class="token keyword">int</span> pos1 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> pos2 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//上一行最小及次小值所在的列</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>pos1 <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">?</span> INT_MAX <span class="token operator">:</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>pos1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//当前值小于等于最小值时,同时更新pos1和pos2</span>                pos2 <span class="token operator">=</span> pos1<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//此处应该先更新pos2,然后更新pos1</span>                pos1 <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>pos2 <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">?</span> INT_MAX <span class="token operator">:</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span>pos2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//当前值大于最小值,小于次小值时,更新pos2</span>                pos2 <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> pos1 <span class="token operator">?</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>pos1<span class="token punctuation">]</span> <span class="token operator">:</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>pos2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">+</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            pos1 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> pos2 <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//需重置 计算当前行数字和最小及次小所在的列</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token punctuation">(</span>pos1 <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">?</span> INT_MAX <span class="token operator">:</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>pos1<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    pos2 <span class="token operator">=</span> pos1<span class="token punctuation">;</span>                    pos1 <span class="token operator">=</span> j<span class="token punctuation">;</span>                 <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>pos2 <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">?</span> INT_MAX <span class="token operator">:</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>pos2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    pos2 <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>pos1<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//感谢热心作者：秦时明月</span><span class="token comment" spellcheck="true">//链接：https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/r8obm3/?discussion=rQGrX1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信文件过期solution</title>
      <link href="/2022/09/10/%E5%BE%AE%E4%BF%A1%E6%96%87%E4%BB%B6%E8%BF%87%E6%9C%9Fsolution/"/>
      <url>/2022/09/10/%E5%BE%AE%E4%BF%A1%E6%96%87%E4%BB%B6%E8%BF%87%E6%9C%9Fsolution/</url>
      
        <content type="html"><![CDATA[<p>cr.豆瓣句号小组</p><div align="center"><img src="/images/微信文件过期solution/1.jpg" width="55%"><img src="/images/微信文件过期solution/2.jpg" width="55%"><img src="/images/微信文件过期solution/3.jpg" width="55%"><img src="/images/微信文件过期solution/4.jpg" width="55%"><img src="/images/微信文件过期solution/5.jpg" width="55%"></div><font face="微软雅黑" size>**方法2**</font><div align="center"><img src="/images/微信文件过期solution/6.jpg" width="55%"><img src="/images/微信文件过期solution/7.jpg" width="55%"><img src="/images/微信文件过期solution/8.jpg" width="55%"></div><p>【ps】由于句号组的帖子很容易殉o(╥﹏╥)o，所以都截图保存了<br>感谢原作者桃子老师的分享~</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 豆瓣 </tag>
            
            <tag> 实用技巧 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP Day2</title>
      <link href="/2022/09/06/DP-Day2/"/>
      <url>/2022/09/06/DP-Day2/</url>
      
        <content type="html"><![CDATA[<p><font face="微软雅黑" size="6" color="#A52A2A">第一题</font><br>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。<br>说明：每次只能向下或者向右移动一步。<br><img src="/images/DP3.jpg" alt="最小路径和"><br>链接：<a href="https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/rtcz3i/">https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/rtcz3i/</a>  </p><p><strong>思路</strong>大致和DP1的思想一致：<br>1、先定义状态f[m][n]<br>2、找出状态转移函数<br>ps.最重要的就是搞清楚<del>状态定义</del>！！f[m][n]意味着什么？f[m-1][n]又意味着什么？它们之间的关系为什么是这样？搞清楚状态定义基本上解决了这种题目。<br><em>比较简单，直接看代码吧</em></p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minPathSum</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> grid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m<span class="token operator">=</span>grid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n<span class="token operator">=</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> f<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//到(m+1,n+1)点的总长度</span>        f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span>grid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span>                <span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">>=</span>f<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                 <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">+</span>grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><font face="STCAIYUN" size="4" color="#DAA520">原作者宫水三叶的解析</font><br>作者希望通过「最小路径和」问题来分享如何进行「维度合并」来降低“出错风险”和“Debug 难度”。<br>这是 DP 问题中的一个常用技巧：通过「问题等价变换」来降低编码难度。<br><em>这道题也不难，为什么需要等价变换呢？</em><br>作者在进阶版中，输出了总和最低的路径，输出路径可以便于程序员以及参考代码者查看相关路径，便于debug<br>而原做法是<font color="#FF0000">顺序推导</font>的,那么在<em>寻找最短路径的过程中</em>，到不同节点的最短路径index也是<font color="#FF0000">顺序存储</font>的<br>但是由于最短路径<strong>可能多于1条</strong>，所以我们不能直接在存储路径index的数组顺序读取需要输出的路径<br>那么我们只能<font color="#FF0000">倒序读取</font>，而倒序读取必然需要新的数组存储数值，因为我们要正序输出<br>新的数组就会<strong>消耗更多空间</strong><br>因此，我们可以「问题等价变换」</p><hr><p>作者的解决办法：<br><font size="4">1、倒推</font><br>从终点倒推到起点<br><font size="4">2、信息存储</font><br>使用「一维数组」存储「二维信息」，这是一个常见的手段。<br>一维数组：idx的函数，我们可以通过函数得出idx的行和列<br>二维信息：路径点的行和列</p><p>由于之后还有类似的题目所以自己没有写输出路径的代码，以下是热心同学sheepice写的cpp代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> m<span class="token punctuation">,</span> n<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//m代表行，n代表列</span> <span class="token keyword">int</span> <span class="token function">row</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//取得所在行 </span>    <span class="token keyword">return</span> idx <span class="token operator">/</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">col</span><span class="token punctuation">(</span><span class="token keyword">int</span> idx<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//取得所在列 </span>    <span class="token keyword">return</span> idx <span class="token operator">%</span> n<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">getidx</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//得到每一个一维坐标 </span>    <span class="token keyword">return</span> x <span class="token operator">*</span> n <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cin <span class="token operator">>></span> m <span class="token operator">>></span> n<span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">grid</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">vis</span><span class="token punctuation">(</span>m <span class="token operator">*</span> n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//进行数组的输入； </span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cin <span class="token operator">>></span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//因为要进行路径的输出，因此我们的dp路径从后往前</span>    <span class="token comment" spellcheck="true">/*    //先进行初始化,但是这样的初始化是不适合找路径的，因为    并没有在这个初始化的过程中记录下来我们的最短路径     dp[m - 1][n - 1] = grid[m - 1][n - 1];    for(int i = m - 2; i >= 0; i--) {        dp[i][n - 1] = dp[i + 1][n - 1] + grid[i][n - 1];    }    for(int i = n - 2; i>=0; i--) {        dp[m - 1][i] = dp[m - 1][i + 1] + grid[m - 1][i];    }    */</span>        <span class="token comment" spellcheck="true">//开始进行从后往前的递推，并且推的过程记录下来我们的最短路径</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">==</span> m <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> grid<span class="token punctuation">[</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> bot <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> m <span class="token operator">?</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">:</span> INT_MAX<span class="token punctuation">;</span>                <span class="token keyword">int</span> rht <span class="token operator">=</span> j <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> n <span class="token operator">?</span> grid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">:</span> INT_MAX<span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>bot<span class="token punctuation">,</span> rht<span class="token punctuation">)</span><span class="token punctuation">;</span>                vis<span class="token punctuation">[</span><span class="token function">getidx</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> bot <span class="token operator">&lt;</span> rht <span class="token operator">?</span> <span class="token function">getidx</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>j<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">getidx</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token function">getidx</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"最短的路径为："</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m <span class="token operator">+</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span> <span class="token operator">&lt;&lt;</span> <span class="token function">row</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;&lt;</span> <span class="token function">col</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">")->"</span><span class="token punctuation">;</span>        idx <span class="token operator">=</span> vis<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"("</span> <span class="token operator">&lt;&lt;</span> <span class="token function">row</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">","</span> <span class="token operator">&lt;&lt;</span> <span class="token function">col</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">")"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span><span class="token string">"最短的路径和为:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//作者：sheepice</span><span class="token comment" spellcheck="true">//链接：https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/rtb68e/?discussion=d2e6U2</span><span class="token comment" spellcheck="true">//来源：力扣（LeetCode）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><font face="微软雅黑" size="6" color="#A52A2A">第二题</font><br>给定一个三角形 triangle ，找出自顶向下的最小路径和。<br>每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1<br><img src="/images/DP4.png" alt="最小路径和变形"><br><a href="https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/rtfiiv/">作者：宫水三叶，相关链接</a></p><hr><p><strong>初始思路</strong><br>1、使用dp[i][j]存储到[i][j]点的路径和<br>最终要求：i=m-1,j没有要求<br>在运动过程中j始终&lt;=i<br>2、使用二维数组f进行路径记录，f[index[dp]][line]<br>index[dp]表示哪一条路，line表示哪一层<br>不过由于路径多，如何唯一表示index？<br>能不能按累加定义index？<br>。。。<br>然后就卡住了<span class="github-emoji"><span>😅</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f605.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>。。</p><p>没办法了，仔细看了上一题的解析终于知道为什么从后往前推更方便。。。<br>因为只存储最短路径（1条）的idx<br>所以从后往前推，不然得先存在一个数组里再输出（浪费空间）。。<br>不过三角形怎么从idx推出在哪一行哪一列、、、<br>要不开一个一维数组存储三角形的值算了、、、tri<br>完蛋，还是不会记录，不过三角形倒推就没有正推的问题<br>因为从下往上是唯一的，从上往下是不唯一的<br>然后写出来了下面的东西</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">minimumTotal</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> triangle<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> idx<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一维三角形数组的idx</span>        <span class="token keyword">int</span> line<span class="token operator">=</span>triangle<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> tri<span class="token punctuation">[</span><span class="token punctuation">(</span>line<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>line<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> row<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>row<span class="token operator">&lt;</span>line<span class="token punctuation">;</span>row<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> col<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>col<span class="token operator">&lt;=</span>row<span class="token punctuation">;</span>col<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                tri<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token operator">=</span>triangle<span class="token punctuation">[</span>row<span class="token punctuation">]</span><span class="token punctuation">[</span>col<span class="token punctuation">]</span><span class="token punctuation">;</span>                idx<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//以上的最后没用上，是原来想输出路径（failed）写的</span>        <span class="token keyword">int</span> dp<span class="token punctuation">[</span>line<span class="token punctuation">]</span><span class="token punctuation">[</span>line<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">memset</span><span class="token punctuation">(</span>dp<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>line<span class="token number">-1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token punctuation">;</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">--</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span>line<span class="token number">-1</span><span class="token punctuation">)</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>triangle<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">else</span>                <span class="token punctuation">{</span>                    <span class="token keyword">int</span> up<span class="token punctuation">,</span>ulft<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">//up=(j!=i)?dp[i+1][j]+triangle[i][j]:INT_MAX;</span>                    <span class="token comment" spellcheck="true">//ulft=(j!=0)?dp[i+1][j+1]+triangle[i][j]:INT_MAX;</span>                    up<span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>triangle<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    ulft<span class="token operator">=</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>triangle<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span>up<span class="token punctuation">,</span>ulft<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后看评论，如何节约空间的方法：<br>因为对状态是如何转移不感兴趣，程序员在调试的时候感兴趣（debug）<br>由于用户不感兴趣，因此可以直接在原三角形上更改（？有点危险</p><hr><p>作者解析<br>本题是否可以使用DP解决，要分析<strong>有无后效性</strong><br>首先，既然是从上到下的路径，那么最后一个点必然是落在最后一行。<br>对于最后一行的某个位置的值，根据题意只能从上一行的<strong>某一个位置</strong>或者<strong>某两个位置之一</strong>转移而来。<br>同时，我们只关注前一位的累加值是多少，而不关心这个累加值结果是由什么路径而来的。<br>这显然就满足了「无后效性」的定义：我们转移某个状态需要用到某个值，但是并不关心该值是如何而来的。<br>更加的学术表达是：当前某个状态确定后，之后的状态转移与之前的决策无关</p><p>既然可以使用DP解决该问题，那么我们就需要定义「DP状态」： f[i][j]代表到达某个点的最小路径和<br>状态转移：<br>1、每一行 i 具有 i+1 个数字<br>2、只要不是第一列（j!=0）位置上的数，都能通过「左上方」转移过来<br>3、只要不是每行最后一列（j!=i）位置上的数，都能通过「上方」转移而来</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minimumTotal</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> tri<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> tri<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> tri<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> val <span class="token operator">=</span> tri<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> i<span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> f<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr><p><font size="5"><strong>进阶</strong></font><br>递推过程可以发现，在求第 i 行的状态时只依赖于第 i-1 行的状态。<br>那么我们不需要存储所有行的状态值（动规值），可以对空间进行优化。</p><table><tbody><tr><td bgcolor="#1E90FF">DP 空间优化技巧</td></tr></tbody></table>1、滚动数组2、根据状态依赖调整迭代/循环的方向**滚动数组**没有任何的思维难度，只需要将其中一维直接改成 2， 将维的 f[i] 改成 f[i&amp;1] 或者 f[i%2] 即可（推荐前者，在不同架构的机器上，运算效率更加稳定）。这样数组仅存储两行的内容，用完的数据就被覆盖掉```javaclass Solution {    public int minimumTotal(List<list<integer>&gt; tri) {        int n = tri.size();        int ans = Integer.MAX_VALUE;        int[][] f = new int[2][n];        f[0][0] = tri.get(0).get(0);        for (int i = 1; i &lt; n; i++) {            for (int j = 0; j &lt; i + 1; j++) {                int val = tri.get(i).get(j);                f[i &amp; 1][j] = Integer.MAX_VALUE;                if (j != 0) f[i &amp; 1][j] = Math.min(f[i &amp; 1][j], f[(i - 1) &amp; 1][j - 1] + val);                if (j != i) f[i &amp; 1][j] = Math.min(f[i &amp; 1][j], f[(i - 1) &amp; 1][j] + val);            }        }        for (int i = 0; i &lt; n; i++) ans = Math.min(ans, f[(n - 1) &amp; 1][i]);        return ans;    }}```</list<integer>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DP Day1</title>
      <link href="/2022/09/06/DP-Day1/"/>
      <url>/2022/09/06/DP-Day1/</url>
      
        <content type="html"><![CDATA[<p><font face="微软雅黑" size="6" color="#A52A2A">第一题</font><br>一个机器人位于一个 m x n&nbsp;网格的左上角 （起始点在下图中标记为 “Start” ）<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。<br>问总共有多少条不同的路径？<br><img src="/images/DP1.png" alt="question"><br>链接：<a href="https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/rtwu06/">https://leetcode.cn/leetbook/read/path-problems-in-dynamic-programming/rtwu06/</a>  </p><p>初步的思路：3*7的地图，只能向右或者向下，总共走8步可以到终点，那么就要考虑右和下这两个动作在向量里的位置。<br>如下图所示，需要向右6步，向下2步，那么就计算2个下元素在向量中的位置（无序）。  </p><table><thead><tr><th>第一个“下”的位置</th><th>第二个“下”的可能</th></tr></thead><tbody><tr><td>0</td><td>7</td></tr><tr><td>1</td><td>6</td></tr><tr><td>2</td><td>5</td></tr><tr><td>。。</td><td>。。</td></tr><tr><td>6</td><td>1</td></tr></tbody></table><p>最后求和，得7*8/2=28<br><em><strong>不过这种思路很难找到通用的公式（哭）</strong></em>  </p><hr><p><strong>直接看解析！</strong><br>有人使用<strong>递归</strong>来解决，递归的关键是1.找到函数关系（把范围变小）2.找到递归结束条件<br>对于这道题来说，范围变小：每移动一步，地图就变小了  </p><p><em>本讲重要知识点</em><br><font face="微软雅黑" size="5" color="#006400">动态规划（DP）</font><br><strong>是什么？</strong>若要解一个给定问题，我们需要解其不同部分（即<strong>子问题</strong>），再<strong>合并子问题的解</strong>以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其<strong>记忆化存储</strong>，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。<br><strong>以下是作者宫水三叶对原题的分析</strong><br>定义 f[i][j]f[i][j] 为到达位置 (i,j)(i,j) 的不同路径数量。<br>那么 f[m-1][n-1]f[m−1][n−1] 就是我们最终的答案，而 f[0][0] = 1是一个显而易见的起始条件。<br>由于题目限定了我们只能<em>往下</em>或者<em>往右</em>移动，因此我们按照<strong>当前可选方向</strong>进行分析：<br>当前位置只能「往下」移动，即有 f[i][j] = f[i-1][j]<br>当前位置只能「往右」移动，即有 f[i][j] = f[i][j-1]<br>当前位置即能「往下」也能「往右」移动，即有 f[i][j] = f[i][j-1] + f[i-1][j]</p><hr><p><em>因为是好久没接触DP类型的题目，基本忘光，这里直接搬上作者对于这道题的总结</em>  </p><ol><li><p>我们是如何确定本题可以使用动态规划来解决的？<br>通常我们要从「有无后效性」进行入手分析。<br>如果对于某个状态，我们可以只关注状态的值，而不需要关注状态是如何转移过来的话，那么这就是一个无后效性的问题，可以考虑使用 DP 解决。<br>另外一个更加实在的技巧，我们还可以通过<em>数据范围</em>来猜测是不是可以用 DP来做。<br>因为DP是一个递推的过程，因此如果数据范围是 10^5~10^6 的话，可以考虑是不是可以使用一维 DP来解决；<br>如果数据范围是 10^2~10^3 的话，可以考虑是不是可以使用二维 DP 来做 …</p></li><li><p>我们是如何确定本题的状态定义的？<br>说实话，DP 的状态定义很大程度是靠经验去猜的。<br>虽然大多数情况都是猜的，但也不是毫无规律，相当一部分题目的状态定义是与「结尾」或「答案」有所关联</p></li><li><p>我们是如何确定状态转移方程的？<br>通常来说，如果我们的状态定义猜对了，状态转移方程就是对「最后一步的分情况讨论」。<br>如果我们有一个对的状态定义的话，基本上状态转移方程就是呼之欲出。<br>因此一定程度上，状态转移方程可以反过来验证我们状态定义猜得是否正确：<br>如果猜了一个状态定义，然后发现无法列出涵盖所有情况（不漏）的状态转移方程，多半就是状态定义猜错了，赶紧换个思路，而不是去死磕状态转移方程。</p></li><li><p>对状态转移的要求是什么？<br>我们的状态转移是要做到「不漏」还是「不重不漏」取决于问题本身：<br>如果是求最值的话，我们只需要确保「不漏」即可，因为重复不影响结果。<br>如果是求方案数的话，我们需要确保「不重不漏」。</p></li><li><p>我们是如何分析动态规划的时间复杂度的？<br>对于动态规划的复杂度/计算量分析，有多少个状态，复杂度/计算量就是多少。<br>因此一维DP的复杂度通常是线性的 O(n) ，而二维DP的复杂度通常是平方的 O(n^2)。</p></li></ol><hr><p><font face="微软雅黑" size="6" color="#A52A2A">第二题</font><br>一个机器人位于一个&nbsp;m x n&nbsp;网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。<br>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br>网格中的障碍物和空位置分别用 1 和 0 来表示。<br><img src="/images/DP2.jpg" alt="question2">  </p><p>第二题是对第一题的巩固，就自己按第一题的思路做了一下。<br>以下是自己写的代码，注释是当时的思路和错误的地方：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">uniquePathsWithObstacles</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span><span class="token operator">&amp;</span> obstacleGrid<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i<span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> obstacleGrid<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> f<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//memset(f,-1,sizeof(f));//加不加对编译没有影响，但不初始化很危险</span>        f<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">(</span>obstacleGrid<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//漏初始条件</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>obstacleGrid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>                 <span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span><span class="token operator">&amp;&amp;</span>j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//右，注意条件，j=0表示只能向右</span>                    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span> f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>f<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//下</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> f<span class="token punctuation">[</span>m<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//f[i][j]:</span><span class="token comment" spellcheck="true">//1,o[i-1][j]=1--f[i][j]=f[i][j-1]</span><span class="token comment" spellcheck="true">//2,o[i][j-1]=1--f[i][j]=f[i-1][j]</span><span class="token comment" spellcheck="true">//3,o[i-1][j-1]=0--f[i][j]=f[i][j-1]+f[i-1][j]</span><span class="token comment" spellcheck="true">//4,o[i-1][j-1]=1--f[i][j]=0</span><span class="token comment" spellcheck="true">//一开始的构思，漏洞百出。。。</span><span class="token comment" spellcheck="true">//注意vector的格式，二维数组初始化</span><span class="token comment" spellcheck="true">//一定要清晰定义f[m][n]</span><span class="token comment" spellcheck="true">//当前的状态去推导下一时刻状态，因此不管怎么样等式右边都是x-m（表示过去）的形式，等式左边就是x（当前）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> C++ </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>累了就休息一下，看一点人间喜剧</title>
      <link href="/2022/09/04/%E7%B4%AF%E4%BA%86%E5%B0%B1%E4%BC%91%E6%81%AF%E4%B8%80%E4%B8%8B%EF%BC%8C%E7%9C%8B%E4%B8%80%E7%82%B9%E4%BA%BA%E9%97%B4%E5%96%9C%E5%89%A7/"/>
      <url>/2022/09/04/%E7%B4%AF%E4%BA%86%E5%B0%B1%E4%BC%91%E6%81%AF%E4%B8%80%E4%B8%8B%EF%BC%8C%E7%9C%8B%E4%B8%80%E7%82%B9%E4%BA%BA%E9%97%B4%E5%96%9C%E5%89%A7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.douban.com/group/topic/220795011/?_i=622889837471b5d&amp;dt_dapp=1">叔叔你别拉了，我害怕</a><br>推荐理由：作者语言描述能力惊人，画面感十足</p><p><a href="https://www.douban.com/group/topic/263019480/?_i=627354628775935&amp;dt_dapp=1">封校期间在QQ上被QQ自动回复社死</a><br>推荐理由：很有意思的自动回复格式，激发没有幽默感的我的灵感</p><p><a href="https://www.douban.com/group/topic/266612983/?_i=62735200bbb8f76&amp;dt_dapp=1">没想到被一个<span class="github-emoji"><span>❤</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>尬住了</a><br>推荐理由：。。。。sorry因为这颗<span class="github-emoji"><span>❤</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/2764.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>我笑出了眼泪</p><p><a href="https://www.douban.com/group/topic/269915014/?_i=62737868e16e5d9&amp;dt_dapp=1">失手把狗狗照片发进工作群，而工作群正在。。。</a><br>推荐理由：what a coincidence</p><p><a href="https://www.douban.com/group/topic/212927406/?_i=632431468dfb472&amp;dt_dapp=1">为了吵架更有气势改名字，结果打错了字</a><br>推荐理由：豆瓣的提示，蛮有意思的，正经中带着一丝丝粗鲁</p><p><a href="https://www.douban.com/group/topic/211953297/?_i=632431948dfb472&amp;dt_dapp=1">朋友误以为我买了gang塞</a><br>推荐理由：本来以为不喜欢这种段子，没想到被lz的朋友温暖到了<span class="github-emoji"><span>😭</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f62d.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p>]]></content>
      
      
      <categories>
          
          <category> 乐一乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 豆瓣 </tag>
            
            <tag> 社死 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
